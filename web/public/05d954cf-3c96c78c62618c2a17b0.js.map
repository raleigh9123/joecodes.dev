{"version":3,"sources":["webpack:///./node_modules/framer-motion/dist/framer-motion.es.js"],"names":["isRefObject","ref","hasOwnProperty","MotionValue","init","value","_this","this","timeDelta","lastUpdated","canTrackVelocity","updateAndNotify","v","render","prev","current","updateSubscribers","forEach","notifySubscriber","renderSubscribers","_a","delta","timestamp","postRender","scheduleVelocityCheck","subscriber","velocityCheck","set","isNaN","parseFloat","prototype","subscribeTo","subscriptions","subscription","updateSubscriber","add","onChange","Set","clearListeners","clear","onRenderRequest","attach","passiveEffect","get","getPrevious","getVelocity","start","animation","stop","Promise","resolve","stopAnimation","then","clearAnimation","isAnimating","destroy","motionValue","VisualElement","parent","children","latest","values","Map","valueSubscriptions","config","update","onUpdate","triggerRender","scheduleRender","element","mount","unmount","externalRef","treePath","depth","subscribe","child","hasValue","key","has","addValue","removeValue","subscribeToValue","unsubscribe","getValue","defaultValue","undefined","forEachValue","callback","getInstance","updateConfig","setSingleStaticValue","setStaticValues","unsubscribeOnChange","unsubscribeOnRender","removeFromParent","_","noop","any","convertBoundingBoxToAxisBox","top","x","min","left","max","right","y","bottom","copyAxisBox","box","zeroDelta","translate","scale","origin","originPoint","_int","transform","Math","round","defaultValueTypes","color","backgroundColor","outlineColor","fill","stroke","borderColor","borderTopColor","borderRightColor","borderBottomColor","borderLeftColor","borderWidth","borderTopWidth","borderRightWidth","borderBottomWidth","borderLeftWidth","borderRadius","radius","borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius","width","maxWidth","height","maxHeight","size","padding","paddingTop","paddingRight","paddingBottom","paddingLeft","margin","marginTop","marginRight","marginBottom","marginLeft","rotate","rotateX","rotateY","rotateZ","scaleX","scaleY","scaleZ","skew","skewX","skewY","distance","translateX","translateY","translateZ","z","perspective","opacity","originX","originY","originZ","zIndex","fillOpacity","strokeOpacity","numOctaves","dimensionValueTypes","test","parse","testValueType","type","findDimensionValueType","find","valueTypes","findValueType","getDefaultValueType","getValueAsType","axes","transformProps","sortTransformProps","a","b","indexOf","operationKey","axesKey","push","transformPropSet","isTransformProp","transformOriginProps","isTransformOriginProp","translateAlias","isCSSVariable","startsWith","pixelsToPercent","pixels","axis","borderCorrectionDefinition","process","viewportBox","valueScaleCorrection","applyTo","boxShadow","_viewportBox","treeScale","shadow","template","createTransformer","xScale","yScale","averageScale","buildHTMLStyles","style","vars","transformOrigin","transformKeys","isLayoutProjectionEnabled","deltaFinal","targetBox","enableHardwareAcceleration","transformTemplate","allowTransformNone","length","hasTransform","hasTransformOrigin","transformIsNone","valueType","valueAsType","bucket","corrected","num","i","layoutReprojection","transformIsDefault","transformString","transformHasZ","sort","numTransformKeys","trim","buildTransform","resetAxis","originAxis","scalePoint","point","applyPointDelta","boxScale","applyAxisDelta","applyBoxDelta","applyAxisTransforms","_final","transforms","scaleKey","originKey","xKeys","yKeys","removePointDelta","removeAxisTransforms","removeAxisDelta","clampProgress","isNear","target","maxDistance","calcOrigin","source","sourceLength","targetLength","updateAxisDelta","sourcePoint","calcTranslate","updateBoxDelta","eachAxis","handler","isKeyframesTarget","Array","isArray","underDampedSpring","stiffness","damping","restDelta","restSpeed","overDampedSpring","to","linearTween","ease","duration","keyframes","defaultTransitions","just","complete","easingDefinitionToFunction","definition","x1","y1","x2","y2","isEasingArray","isAnimatable","secondsToMilliseconds","seconds","transitions","tween","spring","inertia","transitionOptionParser","opts","from","velocity","easings","map","getTransitionDefinition","transitionDefinition","delay","when","delayChildren","staggerChildren","staggerDirection","transition","Object","keys","isTransitionDefined","valueKey","transitionFactory","getDefaultTransition","valueTransitionDefinition","getAnimation","isOriginAnimatable","isTargetAnimatable","_b","actionFactory","preprocessOptions","repeatDelay","startAnimation","delay$1","activeAnimation","animationFactory","valueDelay","options","animate","getBoundingBox","transformPagePoint","transformPoint","topLeft","bottomRight","transformBoundingBox","getBoundingClientRect","HTMLVisualElement","_super","apply","arguments","defaultConfig","reactStyle","hasLayoutChildren","layoutUpdateListeners","hasViewportBoxUpdated","targetBoxFinal","stopLayoutAxisAnimation","isTargetBoxLocked","axisProgress","call","clean","read","getComputedStyle","readNativeValue","defaultValueType","enableLayoutProjection","forEachParent","hide","isVisible","show","onLayoutUpdate","layoutReady","listener","prevViewportBox","getBoundingBoxWithoutTransforms","bbox","window","snapshotBoundingBox","measureLayout","boxCorrected","refreshTargetBox","lockTargetBox","unlockTargetBox","stopLayoutAnimation","resetTransform","setAxisTarget","targetAxis","scheduleChildrenLayoutRender","startLayoutAxisAnimation","progress","updateLayoutDeltas","isReactRender","originBox","p","treeLength","applyTreeDeltas","finalBox","applyBoxTransforms","onViewportBoxUpdate","build","visibility","assign","setProperty","useConstant","calcOrigin$1","offset","progressToPixels","dashKeys","array","camelKeys","unmeasured","buildSVGAttrs","attrs","dimensions","totalPathLength","attrX","attrY","pathLength","pathSpacing","_c","pathOffset","calcSVGTransformOrigin","totalLength","spacing","useDashCase","buildSVGPath","camelCaseAttributes","CAMEL_CASE_PATTERN","camelToDash","str","replace","toLowerCase","SVGVisualElement","measure","getBBox","e","tagName","getTotalLength","getAttribute","setAttribute","svgTagNames","isSVGComponent","Component","PresenceContext","usePresence","context","isPresent","onExitComplete","register","id","useUniqueId","counter","incrementId","validMotionProps","isValidMotionProp","isPropValid","emotionIsPropValid_1","isCSSVariable$1","cssVariableRegex","getVariableValue","match","exec","parseCSSVariable","token","fallback","resolved","getPropertyValue","BoundingBoxDimension","positionalKeys","isPositionalKey","setAndResetVelocity","isNumOrPxType","getPosFromMatrix","matrix","pos","split","getTranslateFromMatrix","pos2","pos3","_bbox","matrix3d","nonTranslationalTransformKeys","filter","positionalValues","checkAndConvertChangedValueTypes","visualElement","transitionEnd","targetPositionalKeys","removedTransformValues","hasAttemptedToRemoveTransformValues","changedValueTypeKeys","toType","fromType","numKeyframes","removedTransforms","removeNonTranslationalTransform","convertedTarget","changedKeys","originBbox","elementComputedStyle","display","originComputedStyle","targetBbox","convertChangedValueTypes","unitConversion","some","hasPositionalKey","AnimationControls","hasMounted","pendingAnimations","componentControls","setVariants","variants","controls","setDefaultTransition","defaultTransition","transitionOverride","animations_1","all","MotionContext","isVariantLabel","isAnimationControls","useMotionContext","parentContext","isStatic","initialState","initial","whileTap","whileHover","layoutId","presenceContext","presenceId","isPresenceRoot","shouldPropagateControls","targetInitial","targetAnimate","initialDependency","animateDependency","isReducedMotion","isInitialOnly","isInitialRender","useInitialOrEveryRender","initialToApply","checkShouldInheritVariant","inherit","isMotionValue","addMotionValues","isStyle","foundMotionValue","reservedNames","empty","resolveFinalValueInKeyframes","VisualElementAnimationControls","makeTargetAnimatable","props","baseTarget","overrides","resolvedOverrides","activeOverrides","setProps","setValues","isActive","priority","_d","resolveVariant","transformValues","targetValue","checkForNewValues","newValueKeys","numNewValues","readValue","getAnimatableNone","variant","custom","getHighestPriority","setOverride","overrideIndex","startOverride","override","clearOverride","highest","resetIsAnimating","overrideTarget","remainingValues","onStart","onComplete","applyVariantLabels","variantLabelList","reverse","animateVariantLabels","animateVariant","animationDefinition","_e","getOriginFromTransition","getOrigin","animatable","animations","valueTarget","allAnimations","variantLabels","label","variantLabel","getAnimations","getChildrenAnimations","animateChildren","last","first","maxStaggerDuration","generateStaggerDuration","childControls","onAnimationStart","onAnimationComplete","checkOverrideIsAnimating","numOverrides","resolvedOverride","addChild","removeChild","resetChildren","useVisualElementAnimation","subscribeToParentControls","parentControls","unmountProps","MotionPluginContext","features","createLock","name","lock","globalHorizontalLock","globalVerticalLock","getGlobalLock","drag","openHorizontal_1","openVertical_1","isViewportScrollBlocked","document","addEventListener","event","preventDefault","passive","unblockViewportScroll","addDomEvent","eventName","removeEventListener","isMouseEvent","PointerEvent","pointerType","MouseEvent","isTouchEvent","touches","defaultPagePoint","pageX","pageY","pointFromTouch","pointType","changedTouches","pointFromMouse","extractEventInfo","getViewportPointFromEvent","Point","wrapHandler","shouldFilterPrimaryPointer","eventHandler","button","filterPrimaryPointer","isBrowser$1","mouseEventNames","pointerdown","pointermove","pointerup","pointercancel","pointerover","pointerout","pointerenter","pointerleave","touchEventNames","getPointerEventName","onpointerdown","ontouchstart","onmousedown","addPointerEvent","usePointerEvent","useDomEvent","subtract","relativeTo","idOrElem","elem","localElem","getElementById","rect","scrollX","scrollY","PanSession","handlers","startEvent","lastMoveEvent","lastMoveEventInfo","updatePoint","info","getPanInfo","history","isPanStarted","isDistancePastThreshold","onMove","initialInfo","onSessionStart","removeOnPointerMove","handlePointerMove","removeOnPointerUp","handlePointerUp","removeListeners","buttons","end","onEnd","panInfo","updateHandlers","lastDevicePoint","startDevicePoint","getVelocity$1","timestampedPoint","lastPoint","time","currentVelocity","Infinity","calcConstrainedMinPoint","constraints","elastic","applyConstraints","calcRelativeAxisConstraints","calcViewportAxisConstraints","layoutAxis","constraintsAxis","lastPointerEvent","elementDragControls","WeakMap","VisualElementDragControls","isDragging","currentDirection","cursorProgress","openGlobalLock","panSession","originEvent","snapToCursor","stopMotion","dragPropagation","prepareBoundingBox","resolveDragConstraints","onDragStart","dragDirectionLock","lockThreshold","direction","abs","getCurrentDirection","onDirectionLock","updateAxis","onDrag","dragConstraints","resolveRefConstraints","layoutBox","calcRelativeConstraints","onMeasureDragConstraints","constraintsElement","constraintsBox","measuredConstraints","calcViewportConstraints","userConstraints","convertAxisBoxToBoundingBox","cancelDrag","dragMomentum","dragElastic","onDragEnd","animateDragEnd","shouldDrag","axisLayout","axisLength","updateProps","_f","_g","remainingProps","dragTransition","momentumAnimations","bounceStiffness","bounceDamping","timeConstant","onDragTransitionEnd","boxProgress","calcPositionFromProgress","stopPointerListener","dragListener","stopResizeListener","stopLayoutUpdateListener","prevSnapshot","makeRenderlessComponent","hook","Drag","shouldRender","groupDragControls","dragControls","useDrag","useUnmountEffect","order$1","getGesturePriority","gesture","tapGesturePriority","hoverPriority","filterTouch","useGestures","onPan","onPanStart","onPanEnd","onPanSessionStart","hasPanEvents","usePanGesture","onTap","onTapStart","onTapCancel","hasTapListeners","isTapping","cancelPointerEventListener","removePointerUp","onPointerUp","openGestureLock","isNodeOrChild","parentElement","useTapGesture","onHoverStart","onHoverEnd","useHoverGesture","AnimatePropType","gestureProps","Gestures","Exit","exit","isPlayingExitAnimation","targetWithoutTransition","mergeTransitionEnd","resolveVariantLabels","unresolvedVariant","Presence","VisibilityAction","AnimatePropComponents","Target","targetAndTransition","prevValues","next","targetToAnimate","animatingTarget","finalTarget","shouldAnimateOnMount","isValidValue","valueHasUpdated","prevLength","shallowCompare","useAnimateProp","VariantLabel","targetVariants","parentAlreadyMounted","oldVariant","newVariant","shouldAnimate","join","useVariants","AnimationSubscription","useAnimationGroupSubscription","isAnimationSubscription","animationProps","animatePropTypeTests","prop","Animate","frameTarget","stopAxisAnimation","visibilityAction","layout","boxHasMoved","hasMoved","animateAxis","Hide","onLayoutAnimationComplete","presence","Present","safeToRemove","componentDidMount","unsubLayoutReady","componentWillUnmount","crossfadeOpacity","layoutProgress","crossfade","createCrossfadeAnimation","frame","tweenAxis","unsubscribeProgress","easeCrossfadeIn","easeCrossfadeOut","AnimateLayout","hasAxisMoved","compress","easing","defaultHandler","sortByDepth","createBatcher","queue","flush","order","isSharedLayout","forceUpdate","SharedLayoutContext","Measure","syncLayout","componentDidUpdate","getSnapshotBeforeUpdate","syncUpdate","defaultFeatures","createElement","useFeatures","shouldInheritVariant","plugins","allFeatures","numFeatures","Animation","animatePropType","getAnimationComponent","localContext","createMotionComponent","useVisualElement","animationControlsConfig","isTransform","existsAsProp","existsAsStyle","propIsMotionValue","styleIsMotionValue","useMotionValues","component","remove","useSnapshotOnUnmount","Provider","forwardedProps","domProps","filterProps","visualProps","buildSVGProps","htmlProps","userSelect","draggable","buildHTMLProps","HTMLElement","resolveCSSVariables","componentCache","motion","Proxy","createSwitchAnimation","stack","lead","Entering","prevLead","Show","getFollowOrigin","Exiting","getFollowTarget","stackLead","stackLeadPresence","follow","getLeadTransition","getLeadTarget","getLeadOrigin","LayoutStack","hasChildren","layoutOrder","index","findIndex","stackChild","splice","snapshot","boundingBox","latestMotionValues","updateLeadAndFollow","prevFollow","leadIndex","numInStack","lastIsPresent","findLeadAndFollow","updateSnapshot","isLeadPresent","shouldStackAnimate","AnimateSharedLayout","stacks","updateScheduled","renderScheduled","syncContext","force","scheduleUpdate","updateStacks","startLayoutAnimation","shouldComponentUpdate","createAnimation","getStack","addToStack","removeFromStack","createScrollMotionValues","scrollXProgress","scrollYProgress","prefersReducedMotion","matchMedia","motionMediaQuery_1","setReducedMotionPreferences","matches","addListener","DragControls","nativeEvent","StateVisualElement"],"mappings":"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","file":"05d954cf-3c96c78c62618c2a17b0.js","sourcesContent":["import \"core-js/modules/es7.object.values\";\nimport \"core-js/modules/es6.array.find-index\";\nimport \"core-js/modules/es6.weak-map\";\nimport \"core-js/modules/es6.array.from\";\nimport \"core-js/modules/es6.array.filter\";\nimport \"core-js/modules/es6.regexp.match\";\nimport \"core-js/modules/es6.regexp.split\";\nimport \"core-js/modules/es6.array.some\";\nimport \"core-js/modules/es6.regexp.replace\";\nimport \"core-js/modules/es6.object.assign\";\nimport \"core-js/modules/es6.object.keys\";\nimport \"core-js/modules/es6.array.map\";\nimport \"core-js/modules/es6.array.is-array\";\nimport \"core-js/modules/es6.string.starts-with\";\nimport \"core-js/modules/es6.string.trim\";\nimport \"core-js/modules/es6.array.sort\";\nimport \"core-js/modules/es6.array.index-of\";\nimport \"core-js/modules/es6.array.find\";\nimport \"core-js/modules/es6.map\";\nimport \"core-js/modules/es6.promise\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.array.iterator\";\nimport \"core-js/modules/es6.object.to-string\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.set\";\nimport \"core-js/modules/es6.array.for-each\";\nimport { __assign, __spreadArrays, __rest, __extends } from 'tslib';\nimport sync, { getFrameData, cancelSync } from 'framesync';\nimport { velocityPerSecond, mix, clamp, distance, progress, linear as linear$1, circOut, interpolate, wrap } from '@popmotion/popcorn';\nimport { invariant, warning } from 'hey-listen';\nimport { number, color, complex, px, percent, degrees, vw, vh, scale, alpha, progressPercentage } from 'style-value-types';\nimport { action, delay, tween, spring, keyframes as keyframes$1, inertia } from 'popmotion';\nimport * as easingLookup from '@popmotion/easing';\nimport { cubicBezier, linear } from '@popmotion/easing';\nimport React__default, { useRef, createContext, useContext, useEffect, createElement, useMemo, Component, forwardRef, Fragment, useCallback, useState, cloneElement, Children, isValidElement, useLayoutEffect } from 'react';\n\nvar isRefObject = function isRefObject(ref) {\n  return typeof ref === \"object\" && ref.hasOwnProperty(\"current\");\n};\n\nvar isFloat = function isFloat(value) {\n  return !isNaN(parseFloat(value));\n};\n/**\n * `MotionValue` is used to track the state and velocity of motion values.\n *\n * @public\n */\n\n\nvar MotionValue =\n/** @class */\nfunction () {\n  /**\n   * @param init - The initiating value\n   * @param config - Optional configuration options\n   *\n   * -  `transformer`: A function to transform incoming values with.\n   *\n   * @internal\n   */\n  function MotionValue(init) {\n    var _this = this;\n    /**\n     * Duration, in milliseconds, since last updating frame.\n     *\n     * @internal\n     */\n\n\n    this.timeDelta = 0;\n    /**\n     * Timestamp of the last time this `MotionValue` was updated.\n     *\n     * @internal\n     */\n\n    this.lastUpdated = 0;\n    /**\n     * Tracks whether this value can output a velocity. Currently this is only true\n     * if the value is numerical, but we might be able to widen the scope here and support\n     * other value types.\n     *\n     * @internal\n     */\n\n    this.canTrackVelocity = false;\n\n    this.updateAndNotify = function (v, render) {\n      if (render === void 0) {\n        render = true;\n      }\n\n      _this.prev = _this.current;\n      _this.current = v;\n\n      if (_this.updateSubscribers && _this.prev !== _this.current) {\n        _this.updateSubscribers.forEach(_this.notifySubscriber);\n      }\n\n      if (render && _this.renderSubscribers) {\n        _this.renderSubscribers.forEach(_this.notifySubscriber);\n      } // Update timestamp\n\n\n      var _a = getFrameData(),\n          delta = _a.delta,\n          timestamp = _a.timestamp;\n\n      if (_this.lastUpdated !== timestamp) {\n        _this.timeDelta = delta;\n        _this.lastUpdated = timestamp;\n        sync.postRender(_this.scheduleVelocityCheck);\n      }\n    };\n    /**\n     * Notify a subscriber with the latest value.\n     *\n     * This is an instanced and bound function to prevent generating a new\n     * function once per frame.\n     *\n     * @param subscriber - The subscriber to notify.\n     *\n     * @internal\n     */\n\n\n    this.notifySubscriber = function (subscriber) {\n      subscriber(_this.current);\n    };\n    /**\n     * Schedule a velocity check for the next frame.\n     *\n     * This is an instanced and bound function to prevent generating a new\n     * function once per frame.\n     *\n     * @internal\n     */\n\n\n    this.scheduleVelocityCheck = function () {\n      return sync.postRender(_this.velocityCheck);\n    };\n    /**\n     * Updates `prev` with `current` if the value hasn't been updated this frame.\n     * This ensures velocity calculations return `0`.\n     *\n     * This is an instanced and bound function to prevent generating a new\n     * function once per frame.\n     *\n     * @internal\n     */\n\n\n    this.velocityCheck = function (_a) {\n      var timestamp = _a.timestamp;\n\n      if (timestamp !== _this.lastUpdated) {\n        _this.prev = _this.current;\n      }\n    };\n\n    this.set(init, false);\n    this.canTrackVelocity = isFloat(this.current);\n  }\n  /**\n   * Subscribes a subscriber function to a subscription list.\n   *\n   * @param subscriptions - A `Set` of subscribers.\n   * @param subscription - A subscriber function.\n   */\n\n\n  MotionValue.prototype.subscribeTo = function (subscriptions, subscription) {\n    var _this = this;\n\n    var updateSubscriber = function updateSubscriber() {\n      return subscription(_this.current);\n    };\n\n    subscriptions.add(updateSubscriber);\n    return function () {\n      return subscriptions[\"delete\"](updateSubscriber);\n    };\n  };\n  /**\n   * Adds a function that will be notified when the `MotionValue` is updated.\n   *\n   * It returns a function that, when called, will cancel the subscription.\n   *\n   * When calling `onChange` inside a React component, it should be wrapped with the\n   * `useEffect` hook. As it returns an unsubscribe function, this should be returned\n   * from the `useEffect` function to ensure you don't add duplicate subscribers..\n   *\n   * @library\n   *\n   * ```jsx\n   * function MyComponent() {\n   *   const x = useMotionValue(0)\n   *   const y = useMotionValue(0)\n   *   const opacity = useMotionValue(1)\n   *\n   *   useEffect(() => {\n   *     function updateOpacity() {\n   *       const maxXY = Math.max(x.get(), y.get())\n   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\n   *       opacity.set(newOpacity)\n   *     }\n   *\n   *     const unsubscribeX = x.onChange(updateOpacity)\n   *     const unsubscribeY = y.onChange(updateOpacity)\n   *\n   *     return () => {\n   *       unsubscribeX()\n   *       unsubscribeY()\n   *     }\n   *   }, [])\n   *\n   *   return <Frame x={x} />\n   * }\n   * ```\n   *\n   * @motion\n   *\n   * ```jsx\n   * export const MyComponent = () => {\n   *   const x = useMotionValue(0)\n   *   const y = useMotionValue(0)\n   *   const opacity = useMotionValue(1)\n   *\n   *   useEffect(() => {\n   *     function updateOpacity() {\n   *       const maxXY = Math.max(x.get(), y.get())\n   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\n   *       opacity.set(newOpacity)\n   *     }\n   *\n   *     const unsubscribeX = x.onChange(updateOpacity)\n   *     const unsubscribeY = y.onChange(updateOpacity)\n   *\n   *     return () => {\n   *       unsubscribeX()\n   *       unsubscribeY()\n   *     }\n   *   }, [])\n   *\n   *   return <motion.div style={{ x }} />\n   * }\n   * ```\n   *\n   * @internalremarks\n   *\n   * We could look into a `useOnChange` hook if the above lifecycle management proves confusing.\n   *\n   * ```jsx\n   * useOnChange(x, () => {})\n   * ```\n   *\n   * @param subscriber - A function that receives the latest value.\n   * @returns A function that, when called, will cancel this subscription.\n   *\n   * @public\n   */\n\n\n  MotionValue.prototype.onChange = function (subscription) {\n    if (!this.updateSubscribers) this.updateSubscribers = new Set();\n    return this.subscribeTo(this.updateSubscribers, subscription);\n  };\n\n  MotionValue.prototype.clearListeners = function () {\n    var _a;\n\n    (_a = this.updateSubscribers) === null || _a === void 0 ? void 0 : _a.clear();\n  };\n  /**\n   * Adds a function that will be notified when the `MotionValue` requests a render.\n   *\n   * @param subscriber - A function that's provided the latest value.\n   * @returns A function that, when called, will cancel this subscription.\n   *\n   * @internal\n   */\n\n\n  MotionValue.prototype.onRenderRequest = function (subscription) {\n    if (!this.renderSubscribers) this.renderSubscribers = new Set(); // Render immediately\n\n    this.notifySubscriber(subscription);\n    return this.subscribeTo(this.renderSubscribers, subscription);\n  };\n  /**\n   * Attaches a passive effect to the `MotionValue`.\n   *\n   * @internal\n   */\n\n\n  MotionValue.prototype.attach = function (passiveEffect) {\n    this.passiveEffect = passiveEffect;\n  };\n  /**\n   * Sets the state of the `MotionValue`.\n   *\n   * @remarks\n   *\n   * ```jsx\n   * const x = useMotionValue(0)\n   * x.set(10)\n   * ```\n   *\n   * @param latest - Latest value to set.\n   * @param render - Whether to notify render subscribers. Defaults to `true`\n   *\n   * @public\n   */\n\n\n  MotionValue.prototype.set = function (v, render) {\n    if (render === void 0) {\n      render = true;\n    }\n\n    if (!render || !this.passiveEffect) {\n      this.updateAndNotify(v, render);\n    } else {\n      this.passiveEffect(v, this.updateAndNotify);\n    }\n  };\n  /**\n   * Returns the latest state of `MotionValue`\n   *\n   * @returns - The latest state of `MotionValue`\n   *\n   * @public\n   */\n\n\n  MotionValue.prototype.get = function () {\n    return this.current;\n  };\n  /**\n   * @public\n   */\n\n\n  MotionValue.prototype.getPrevious = function () {\n    return this.prev;\n  };\n  /**\n   * Returns the latest velocity of `MotionValue`\n   *\n   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.\n   *\n   * @public\n   */\n\n\n  MotionValue.prototype.getVelocity = function () {\n    // This could be isFloat(this.prev) && isFloat(this.current), but that would be wasteful\n    return this.canTrackVelocity ? // These casts could be avoided if parseFloat would be typed better\n    velocityPerSecond(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta) : 0;\n  };\n  /**\n   * Registers a new animation to control this `MotionValue`. Only one\n   * animation can drive a `MotionValue` at one time.\n   *\n   * ```jsx\n   * value.start()\n   * ```\n   *\n   * @param animation - A function that starts the provided animation\n   *\n   * @internal\n   */\n\n\n  MotionValue.prototype.start = function (animation) {\n    var _this = this;\n\n    this.stop();\n    return new Promise(function (resolve) {\n      _this.stopAnimation = animation(resolve);\n    }).then(function () {\n      return _this.clearAnimation();\n    });\n  };\n  /**\n   * Stop the currently active animation.\n   *\n   * @public\n   */\n\n\n  MotionValue.prototype.stop = function () {\n    if (this.stopAnimation) this.stopAnimation();\n    this.clearAnimation();\n  };\n  /**\n   * Returns `true` if this value is currently animating.\n   *\n   * @public\n   */\n\n\n  MotionValue.prototype.isAnimating = function () {\n    return !!this.stopAnimation;\n  };\n\n  MotionValue.prototype.clearAnimation = function () {\n    this.stopAnimation = null;\n  };\n  /**\n   * Destroy and clean up subscribers to this `MotionValue`.\n   *\n   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically\n   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually\n   * created a `MotionValue` via the `motionValue` function.\n   *\n   * @public\n   */\n\n\n  MotionValue.prototype.destroy = function () {\n    this.updateSubscribers && this.updateSubscribers.clear();\n    this.renderSubscribers && this.renderSubscribers.clear();\n    this.stop();\n  };\n\n  return MotionValue;\n}();\n/**\n * @internal\n */\n\n\nfunction motionValue(init) {\n  return new MotionValue(init);\n}\n/**\n * VisualElement is an abstract class that provides a generic animation-optimised interface to the\n * underlying renderer.\n *\n * Currently many features interact directly with HTMLVisualElement/SVGVisualElement\n * but the idea is we can create, for instance, a ThreeVisualElement that extends\n * VisualElement and we can quickly offer all the same features.\n */\n\n\nvar VisualElement =\n/** @class */\nfunction () {\n  function VisualElement(parent, ref) {\n    var _this = this; // An iterable list of current children\n\n\n    this.children = new Set(); // The latest resolved MotionValues\n\n    this.latest = {}; // A map of MotionValues used to animate this element\n\n    this.values = new Map(); // Unsubscription callbacks for each MotionValue\n\n    this.valueSubscriptions = new Map(); // A configuration for this VisualElement, each derived class can extend this.\n\n    this.config = {}; // A pre-bound call to the user-provided `onUpdate` callback. This won't\n    // be called more than once per frame.\n\n    this.update = function () {\n      return _this.config.onUpdate(_this.latest);\n    }; // Pre-bound version of render\n\n\n    this.triggerRender = function () {\n      return _this.render();\n    };\n\n    this.scheduleRender = function () {\n      return sync.render(_this.triggerRender, false, true);\n    }; // This function gets passed to the rendered component's `ref` prop\n    // and is used to mount/unmount the VisualElement\n\n\n    this.ref = function (element) {\n      element ? _this.mount(element) : _this.unmount();\n      if (!_this.externalRef) return;\n\n      if (typeof _this.externalRef === \"function\") {\n        _this.externalRef(element);\n      } else if (isRefObject(_this.externalRef)) {\n        _this.externalRef.current = element;\n      }\n    }; // Create a relationship with the provided parent. When we come to replace\n    // the auto-animation stuff with VisualElement we might need to make this\n    // relationship two-way\n\n\n    this.parent = parent;\n    this.treePath = parent ? __spreadArrays(parent.treePath, [parent]) : []; // Calculate the depth of this node in the VisualElement graph\n\n    this.depth = parent ? parent.depth + 1 : 0; // A reference to any externally-defined React ref. This might live better\n    // outside the VisualElement and be handled in a hook.\n\n    this.externalRef = ref;\n  }\n\n  VisualElement.prototype.subscribe = function (child) {\n    var _this = this;\n\n    this.children.add(child);\n    return function () {\n      return _this.children[\"delete\"](child);\n    };\n  }; // Check whether this element has a MotionValue of the provided key\n\n\n  VisualElement.prototype.hasValue = function (key) {\n    return this.values.has(key);\n  }; // Add a MotionValue\n\n\n  VisualElement.prototype.addValue = function (key, value) {\n    if (this.hasValue(key)) this.removeValue(key);\n    this.values.set(key, value);\n    this.latest[key] = value.get();\n    if (this.element) this.subscribeToValue(key, value);\n  }; // Remove a MotionValue\n\n\n  VisualElement.prototype.removeValue = function (key) {\n    var unsubscribe = this.valueSubscriptions.get(key);\n    unsubscribe && unsubscribe();\n    this.values[\"delete\"](key);\n    delete this.latest[key];\n    this.valueSubscriptions[\"delete\"](key);\n  };\n\n  VisualElement.prototype.getValue = function (key, defaultValue) {\n    var value = this.values.get(key);\n\n    if (value === undefined && defaultValue !== undefined) {\n      value = new MotionValue(defaultValue);\n      this.addValue(key, value);\n    }\n\n    return value;\n  }; // Iterate over all MotionValues\n\n\n  VisualElement.prototype.forEachValue = function (callback) {\n    this.values.forEach(callback);\n  }; // Get the underlying rendered instance of this VisualElement. For instance in\n  // HTMLVisualElement this will be a HTMLElement.\n\n\n  VisualElement.prototype.getInstance = function () {\n    return this.element;\n  };\n\n  VisualElement.prototype.updateConfig = function (config) {\n    if (config === void 0) {\n      config = {};\n    }\n\n    this.config = __assign({}, config);\n  }; // Set a single `latest` value\n\n\n  VisualElement.prototype.setSingleStaticValue = function (key, value) {\n    this.latest[key] = value;\n  }; // Statically set values to `latest` without needing a MotionValue\n\n\n  VisualElement.prototype.setStaticValues = function (values, value) {\n    if (typeof values === \"string\") {\n      this.setSingleStaticValue(values, value);\n    } else {\n      for (var key in values) {\n        this.setSingleStaticValue(key, values[key]);\n      }\n    }\n  }; // Subscribe to changes in a MotionValue\n\n\n  VisualElement.prototype.subscribeToValue = function (key, value) {\n    var _this = this;\n\n    var onChange = function onChange(latest) {\n      _this.setSingleStaticValue(key, latest);\n\n      _this.latest[key] = latest;\n      _this.config.onUpdate && sync.update(_this.update, false, true);\n    };\n\n    var unsubscribeOnChange = value.onChange(onChange);\n    var unsubscribeOnRender = value.onRenderRequest(this.scheduleRender);\n    this.valueSubscriptions.set(key, function () {\n      unsubscribeOnChange();\n      unsubscribeOnRender();\n    });\n  }; // Mount the VisualElement with the actual DOM element\n\n\n  VisualElement.prototype.mount = function (element) {\n    var _this = this;\n\n    invariant(!!element, \"No ref found. Ensure components created with motion.custom forward refs using React.forwardRef\");\n\n    if (this.parent) {\n      this.removeFromParent = this.parent.subscribe(this);\n      /**\n       * Save a reference to the nearest layout projecting ancestor.\n       */\n      // this.layoutParent = this.parent.isLayoutProjectionEnabled\n      //     ? this.parent\n      //     : this.parent.layoutParent\n    }\n    /**\n     * Save the element to this.element as a semantic API, this.current to the VisualElement\n     * is compatible with existing RefObject APIs.\n     */\n\n\n    this.element = this.current = element; // Subscribe to any pre-existing MotionValues\n\n    this.forEachValue(function (value, key) {\n      return _this.subscribeToValue(key, value);\n    });\n  }; // Unmount the VisualElement and cancel any scheduled updates\n\n\n  VisualElement.prototype.unmount = function () {\n    var _this = this;\n\n    this.forEachValue(function (_, key) {\n      return _this.removeValue(key);\n    });\n    cancelSync.update(this.update);\n    cancelSync.render(this.render);\n    this.removeFromParent && this.removeFromParent();\n  };\n\n  return VisualElement;\n}();\n\nfunction noop(any) {\n  return any;\n}\n/**\n * Bounding boxes tend to be defined as top, left, right, bottom. For various operations\n * it's easier to consider each axis individually. This function returns a bounding box\n * as a map of single-axis min/max values.\n */\n\n\nfunction convertBoundingBoxToAxisBox(_a) {\n  var top = _a.top,\n      left = _a.left,\n      right = _a.right,\n      bottom = _a.bottom;\n  return {\n    x: {\n      min: left,\n      max: right\n    },\n    y: {\n      min: top,\n      max: bottom\n    }\n  };\n}\n\nfunction convertAxisBoxToBoundingBox(_a) {\n  var x = _a.x,\n      y = _a.y;\n  return {\n    top: y.min,\n    bottom: y.max,\n    left: x.min,\n    right: x.max\n  };\n}\n/**\n * Applies a TransformPoint function to a bounding box. TransformPoint is usually a function\n * provided by Framer to allow measured points to be corrected for device scaling. This is used\n * when measuring DOM elements and DOM event points.\n */\n\n\nfunction transformBoundingBox(_a, transformPoint) {\n  var top = _a.top,\n      left = _a.left,\n      bottom = _a.bottom,\n      right = _a.right;\n\n  if (transformPoint === void 0) {\n    transformPoint = noop;\n  }\n\n  var topLeft = transformPoint({\n    x: left,\n    y: top\n  });\n  var bottomRight = transformPoint({\n    x: right,\n    y: bottom\n  });\n  return {\n    top: topLeft.y,\n    left: topLeft.x,\n    bottom: bottomRight.y,\n    right: bottomRight.x\n  };\n}\n/**\n * Create an empty axis box of zero size\n */\n\n\nfunction axisBox() {\n  return {\n    x: {\n      min: 0,\n      max: 1\n    },\n    y: {\n      min: 0,\n      max: 1\n    }\n  };\n}\n\nfunction copyAxisBox(box) {\n  return {\n    x: __assign({}, box.x),\n    y: __assign({}, box.y)\n  };\n}\n/**\n * Create an empty box delta\n */\n\n\nvar zeroDelta = {\n  translate: 0,\n  scale: 1,\n  origin: 0,\n  originPoint: 0\n};\n\nfunction delta() {\n  return {\n    x: __assign({}, zeroDelta),\n    y: __assign({}, zeroDelta)\n  };\n}\n/**\n * ValueType for \"auto\"\n */\n\n\nvar auto = {\n  test: function test(v) {\n    return v === \"auto\";\n  },\n  parse: function parse(v) {\n    return v;\n  }\n};\n/**\n * ValueType for ints\n */\n\nvar _int = __assign(__assign({}, number), {\n  transform: Math.round\n});\n/**\n * A map of default value types for common values\n */\n\n\nvar defaultValueTypes = {\n  // Color props\n  color: color,\n  backgroundColor: color,\n  outlineColor: color,\n  fill: color,\n  stroke: color,\n  // Border props\n  borderColor: color,\n  borderTopColor: color,\n  borderRightColor: color,\n  borderBottomColor: color,\n  borderLeftColor: color,\n  borderWidth: px,\n  borderTopWidth: px,\n  borderRightWidth: px,\n  borderBottomWidth: px,\n  borderLeftWidth: px,\n  borderRadius: px,\n  radius: px,\n  borderTopLeftRadius: px,\n  borderTopRightRadius: px,\n  borderBottomRightRadius: px,\n  borderBottomLeftRadius: px,\n  // Positioning props\n  width: px,\n  maxWidth: px,\n  height: px,\n  maxHeight: px,\n  size: px,\n  top: px,\n  right: px,\n  bottom: px,\n  left: px,\n  // Spacing props\n  padding: px,\n  paddingTop: px,\n  paddingRight: px,\n  paddingBottom: px,\n  paddingLeft: px,\n  margin: px,\n  marginTop: px,\n  marginRight: px,\n  marginBottom: px,\n  marginLeft: px,\n  // Transform props\n  rotate: degrees,\n  rotateX: degrees,\n  rotateY: degrees,\n  rotateZ: degrees,\n  scale: scale,\n  scaleX: scale,\n  scaleY: scale,\n  scaleZ: scale,\n  skew: degrees,\n  skewX: degrees,\n  skewY: degrees,\n  distance: px,\n  translateX: px,\n  translateY: px,\n  translateZ: px,\n  x: px,\n  y: px,\n  z: px,\n  perspective: px,\n  opacity: alpha,\n  originX: progressPercentage,\n  originY: progressPercentage,\n  originZ: px,\n  // Misc\n  zIndex: _int,\n  // SVG\n  fillOpacity: alpha,\n  strokeOpacity: alpha,\n  numOctaves: _int\n};\n/**\n * A list of value types commonly used for dimensions\n */\n\nvar dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];\n/**\n * Tests a provided value against a ValueType\n */\n\nvar testValueType = function testValueType(v) {\n  return function (type) {\n    return type.test(v);\n  };\n};\n/**\n * Tests a dimensional value against the list of dimension ValueTypes\n */\n\n\nvar findDimensionValueType = function findDimensionValueType(v) {\n  return dimensionValueTypes.find(testValueType(v));\n};\n/**\n * A list of all ValueTypes\n */\n\n\nvar valueTypes = __spreadArrays(dimensionValueTypes, [color, complex]);\n/**\n * Tests a value against the list of ValueTypes\n */\n\n\nvar findValueType = function findValueType(v) {\n  return valueTypes.find(testValueType(v));\n};\n/**\n * Gets the default ValueType for the provided value key\n */\n\n\nvar getDefaultValueType = function getDefaultValueType(key) {\n  return defaultValueTypes[key];\n};\n/**\n * Provided a value and a ValueType, returns the value as that value type.\n */\n\n\nvar getValueAsType = function getValueAsType(value, type) {\n  return type && typeof value === \"number\" ? type.transform(value) : value;\n};\n/**\n * A list of all transformable axes. We'll use this list to generated a version\n * of each axes for each transform.\n */\n\n\nvar axes = [\"\", \"X\", \"Y\", \"Z\"];\n/**\n * An ordered array of each transformable value. By default, transform values\n * will be sorted to this order.\n */\n\nvar order = [\"translate\", \"scale\", \"rotate\", \"skew\", \"transformPerspective\"];\n/**\n * Generate a list of every possible transform key.\n */\n\nvar transformProps = [\"x\", \"y\", \"z\"];\norder.forEach(function (operationKey) {\n  axes.forEach(function (axesKey) {\n    return transformProps.push(operationKey + axesKey);\n  });\n});\n/**\n * A function to use with Array.sort to sort transform keys by their default order.\n */\n\nfunction sortTransformProps(a, b) {\n  return transformProps.indexOf(a) - transformProps.indexOf(b);\n}\n/**\n * A quick lookup for transform props.\n */\n\n\nvar transformPropSet = new Set(transformProps);\n\nfunction isTransformProp(key) {\n  return transformPropSet.has(key);\n}\n/**\n * A quick lookup for transform origin props\n */\n\n\nvar transformOriginProps = new Set([\"originX\", \"originY\", \"originZ\"]);\n\nfunction isTransformOriginProp(key) {\n  return transformOriginProps.has(key);\n}\n\nvar translateAlias = {\n  x: \"translateX\",\n  y: \"translateY\",\n  z: \"translateZ\"\n};\n/**\n * Build a CSS transform style from individual x/y/scale etc properties.\n *\n * This outputs with a default order of transforms/scales/rotations, this can be customised by\n * providing a transformTemplate function.\n */\n\nfunction buildTransform(transform, transformKeys, transformTemplate, transformIsDefault, enableHardwareAcceleration, allowTransformNone) {\n  if (enableHardwareAcceleration === void 0) {\n    enableHardwareAcceleration = true;\n  }\n\n  if (allowTransformNone === void 0) {\n    allowTransformNone = true;\n  } // The transform string we're going to build into\n\n\n  var transformString = \"\"; // Track whether the defined transform has a defined z so we don't add a\n  // second to enable hardware acceleration\n\n  var transformHasZ = false; // Transform keys into their default order - this will determine the output order.\n\n  transformKeys.sort(sortTransformProps); // Loop over each transform and build them into transformString\n\n  var numTransformKeys = transformKeys.length;\n\n  for (var i = 0; i < numTransformKeys; i++) {\n    var key = transformKeys[i];\n    transformString += (translateAlias[key] || key) + \"(\" + transform[key] + \") \";\n    if (key === \"z\") transformHasZ = true;\n  }\n\n  if (!transformHasZ && enableHardwareAcceleration) {\n    transformString += \"translateZ(0)\";\n  } else {\n    transformString = transformString.trim();\n  } // If we have a custom `transform` template, pass our transform values and\n  // generated transformString to that before returning\n\n\n  if (transformTemplate) {\n    transformString = transformTemplate(transform, transformIsDefault ? \"\" : transformString);\n  } else if (allowTransformNone && transformIsDefault) {\n    transformString = \"none\";\n  }\n\n  return transformString;\n}\n/**\n * Returns true if the provided key is a CSS variable\n */\n\n\nfunction isCSSVariable(key) {\n  return key.startsWith(\"--\");\n}\n\nfunction pixelsToPercent(pixels, axis) {\n  return pixels / (axis.max - axis.min) * 100;\n}\n/**\n * We always correct borderRadius as a percentage rather than pixels to reduce paints.\n * For example, if you are projecting a box that is 100px wide with a 10px borderRadius\n * into a box that is 200px wide with a 20px borderRadius, that is actually a 10%\n * borderRadius in both states. If we animate between the two in pixels that will trigger\n * a paint each time. If we animate between the two in percentage we'll avoid a paint.\n */\n\n\nfunction correctBorderRadius(latest, viewportBox) {\n  /**\n   * If latest is a string, we either presume it's already a percentage, in which case it'll\n   * already be stretched appropriately, or it's another value type which we don't support.\n   */\n  if (typeof latest !== \"number\") return latest;\n  /**\n   * If latest is a number, it's a pixel value. We use the current viewportBox to calculate that\n   * pixel value as a percentage of each axis\n   */\n\n  var x = pixelsToPercent(latest, viewportBox.x);\n  var y = pixelsToPercent(latest, viewportBox.y);\n  return x + \"% \" + y + \"%\";\n}\n\nfunction correctBoxShadow(latest, _viewportBox, delta, treeScale) {\n  // GC Warning - this creates a function and object every frame\n  var shadow = complex.parse(latest);\n  var template = complex.createTransformer(latest); // Calculate the overall context scale\n\n  var xScale = delta.x.scale * treeScale.x;\n  var yScale = delta.y.scale * treeScale.y; // Scale x/y\n\n  shadow[1] /= xScale;\n  shadow[2] /= yScale;\n  /**\n   * Ideally we'd correct x and y scales individually, but because blur and\n   * spread apply to both we have to take a scale average and apply that instead.\n   * We could potentially improve the outcome of this by incorporating the ratio between\n   * the two scales.\n   */\n\n  var averageScale = mix(xScale, yScale, 0.5); // Blur\n\n  if (typeof shadow[3] === \"number\") shadow[3] /= averageScale; // Spread\n\n  if (typeof shadow[4] === \"number\") shadow[4] /= averageScale;\n  return template(shadow);\n}\n\nvar borderCorrectionDefinition = {\n  process: correctBorderRadius\n};\nvar valueScaleCorrection = {\n  borderRadius: __assign(__assign({}, borderCorrectionDefinition), {\n    applyTo: [\"borderTopLeftRadius\", \"borderTopRightRadius\", \"borderBottomLeftRadius\", \"borderBottomRightRadius\"]\n  }),\n  borderTopLeftRadius: borderCorrectionDefinition,\n  borderTopRightRadius: borderCorrectionDefinition,\n  borderBottomLeftRadius: borderCorrectionDefinition,\n  borderBottomRightRadius: borderCorrectionDefinition,\n  boxShadow: {\n    process: correctBoxShadow\n  }\n};\n/**\n * @internal\n */\n\nfunction addScaleCorrection(correctors) {\n  for (var key in correctors) {\n    valueScaleCorrection[key] = correctors[key];\n  }\n}\n/**\n * Build style and CSS variables\n *\n * This function converts a Motion style prop:\n *\n * { x: 100, width: 100, originX: 0.5 }\n *\n * Into an object with default value types applied and default\n * transform order set:\n *\n * {\n *   transform: 'translateX(100px) translateZ(0)`,\n *   width: '100px',\n *   transformOrigin: '50% 50%'\n * }\n *\n * Styles are saved to `style` and CSS vars to `vars`.\n *\n * This function works with mutative data structures.\n */\n\n\nfunction buildHTMLStyles(latest, style, vars, transform, transformOrigin, transformKeys, _a, isLayoutProjectionEnabled, delta, deltaFinal, treeScale, targetBox) {\n  var enableHardwareAcceleration = _a.enableHardwareAcceleration,\n      transformTemplate = _a.transformTemplate,\n      allowTransformNone = _a.allowTransformNone; // Empty the transformKeys array. As we're throwing out refs to its items\n  // this might not be as cheap as suspected. Maybe using the array as a buffer\n  // with a manual incrementation would be better.\n\n  transformKeys.length = 0; // Track whether we encounter any transform or transformOrigin values.\n\n  var hasTransform = !!isLayoutProjectionEnabled;\n  var hasTransformOrigin = !!isLayoutProjectionEnabled; // Does the calculated transform essentially equal \"none\"?\n\n  var transformIsNone = true;\n  /**\n   * Loop over all our latest animated values and decide whether to handle them\n   * as a style or CSS variable. Transforms and transform origins are kept seperately\n   * for further processing\n   */\n\n  for (var key in latest) {\n    var value = latest[key]; // Convert the value to its default value type, ie 0 -> \"0px\"\n\n    var valueType = getDefaultValueType(key);\n    var valueAsType = getValueAsType(value, valueType);\n\n    if (isTransformProp(key)) {\n      // If this is a transform, flag and enable further transform processing\n      hasTransform = true;\n      transform[key] = valueAsType;\n      transformKeys.push(key);\n      if (!transformIsNone) continue; // If all the transform keys we've so far encountered are their default value\n      // then check to see if this one isn't\n\n      var defaultValue = valueType[\"default\"] !== undefined ? valueType[\"default\"] : 0;\n      if (value !== defaultValue) transformIsNone = false;\n    } else if (isTransformOriginProp(key)) {\n      // If this is a transform origin, flag and enable further transform-origin processing\n      transformOrigin[key] = valueAsType;\n      hasTransformOrigin = true;\n    } else if (key !== \"transform\" || typeof value !== \"function\") {\n      // Handle all remaining values. Decide which map to save to depending\n      // on whether this is a CSS variable\n      var bucket = isCSSVariable(key) ? vars : style; // If we need to perform scale correction, and we have a handler for this\n      // value type (ie borderRadius), perform it\n\n      if (isLayoutProjectionEnabled && valueScaleCorrection[key]) {\n        var corrected = valueScaleCorrection[key].process(value, targetBox, delta, treeScale);\n        /**\n         * Scale-correctable values can define a number of other values to break\n         * down into. For instance borderRadius needs applying to borderBottomLeftRadius etc\n         */\n\n        var applyTo = valueScaleCorrection[key].applyTo;\n\n        if (applyTo) {\n          var num = applyTo.length;\n\n          for (var i = 0; i < num; i++) {\n            bucket[applyTo[i]] = corrected;\n          }\n        } else {\n          bucket[key] = corrected;\n        }\n      } else {\n        bucket[key] = valueAsType;\n      }\n    }\n  } // Only process transform if values aren't defaults\n\n\n  if (hasTransform || transformTemplate) {\n    if (!isLayoutProjectionEnabled) {\n      style.transform = buildTransform(transform, transformKeys, transformTemplate, transformIsNone, enableHardwareAcceleration, allowTransformNone);\n    } else {\n      style.transform = layoutReprojection(deltaFinal, treeScale);\n    }\n  } // Only process transform origin if values aren't default\n\n\n  if (hasTransformOrigin) {\n    var originX = isLayoutProjectionEnabled ? deltaFinal.x.origin * 100 + \"%\" : transformOrigin.originX || \"50%\";\n    var originY = isLayoutProjectionEnabled ? deltaFinal.y.origin * 100 + \"%\" : transformOrigin.originY || \"50%\";\n    var originZ = transformOrigin.originZ || \"0\";\n    style.transformOrigin = originX + \" \" + originY + \" \" + originZ;\n  }\n}\n\nfunction layoutReprojection(delta, treeScale) {\n  var x = delta.x.translate / treeScale.x;\n  var y = delta.y.translate / treeScale.y;\n  var scaleX = delta.x.scale;\n  var scaleY = delta.y.scale;\n  return \"translate3d(\" + x + \"px, \" + y + \"px, 0) scale(\" + scaleX + \", \" + scaleY + \")\";\n}\n/**\n * Reset an axis to the provided origin box.\n *\n * This is a mutative operation.\n */\n\n\nfunction resetAxis(axis, originAxis) {\n  axis.min = originAxis.min;\n  axis.max = originAxis.max;\n}\n/**\n * Reset a box to the provided origin box.\n *\n * This is a mutative operation.\n */\n\n\nfunction resetBox(box, originBox) {\n  resetAxis(box.x, originBox.x);\n  resetAxis(box.y, originBox.y);\n}\n/**\n * Scales a point based on a factor and an originPoint\n */\n\n\nfunction scalePoint(point, scale, originPoint) {\n  var distanceFromOrigin = point - originPoint;\n  var scaled = scale * distanceFromOrigin;\n  return originPoint + scaled;\n}\n/**\n * Applies a translate/scale delta to a point\n */\n\n\nfunction applyPointDelta(point, translate, scale, originPoint, boxScale) {\n  if (boxScale !== undefined) {\n    point = scalePoint(point, boxScale, originPoint);\n  }\n\n  return scalePoint(point, scale, originPoint) + translate;\n}\n/**\n * Applies a translate/scale delta to an axis\n */\n\n\nfunction applyAxisDelta(axis, translate, scale, originPoint, boxScale) {\n  if (translate === void 0) {\n    translate = 0;\n  }\n\n  if (scale === void 0) {\n    scale = 1;\n  }\n\n  axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\n  axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Applies a translate/scale delta to a box\n */\n\n\nfunction applyBoxDelta(box, _a) {\n  var x = _a.x,\n      y = _a.y;\n  applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\n  applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\n}\n/**\n * Apply a transform to an axis from the latest resolved motion values.\n * This function basically acts as a bridge between a flat motion value map\n * and applyAxisDelta\n */\n\n\nfunction applyAxisTransforms(_final, axis, transforms, _a) {\n  var key = _a[0],\n      scaleKey = _a[1],\n      originKey = _a[2]; // Copy the current axis to the final axis before mutation\n\n  _final.min = axis.min;\n  _final.max = axis.max;\n  var originPoint = mix(axis.min, axis.max, transforms[originKey] || 0.5); // Apply the axis delta to the final axis\n\n  applyAxisDelta(_final, transforms[key], transforms[scaleKey], originPoint, transforms.scale);\n}\n/**\n * The names of the motion values we want to apply as translation, scale and origin.\n */\n\n\nvar xKeys = [\"x\", \"scaleX\", \"originX\"];\nvar yKeys = [\"y\", \"scaleY\", \"originY\"];\n/**\n * Apply a transform to a box from the latest resolved motion values.\n */\n\nfunction applyBoxTransforms(finalBox, box, transforms) {\n  applyAxisTransforms(finalBox.x, box.x, transforms, xKeys);\n  applyAxisTransforms(finalBox.y, box.y, transforms, yKeys);\n}\n/**\n * Remove a delta from a point. This is essentially the steps of applyPointDelta in reverse\n */\n\n\nfunction removePointDelta(point, translate, scale, originPoint, boxScale) {\n  point -= translate;\n  point = scalePoint(point, 1 / scale, originPoint);\n\n  if (boxScale !== undefined) {\n    point = scalePoint(point, 1 / boxScale, originPoint);\n  }\n\n  return point;\n}\n/**\n * Remove a delta from an axis. This is essentially the steps of applyAxisDelta in reverse\n */\n\n\nfunction removeAxisDelta(axis, translate, scale, origin, boxScale) {\n  if (translate === void 0) {\n    translate = 0;\n  }\n\n  if (scale === void 0) {\n    scale = 1;\n  }\n\n  if (origin === void 0) {\n    origin = 0.5;\n  }\n\n  var originPoint = mix(axis.min, axis.max, origin) - translate;\n  axis.min = removePointDelta(axis.min, translate, scale, originPoint, boxScale);\n  axis.max = removePointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Remove a transforms from an axis. This is essentially the steps of applyAxisTransforms in reverse\n * and acts as a bridge between motion values and removeAxisDelta\n */\n\n\nfunction removeAxisTransforms(axis, transforms, _a) {\n  var key = _a[0],\n      scaleKey = _a[1],\n      originKey = _a[2];\n  removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale);\n}\n/**\n * Remove a transforms from an box. This is essentially the steps of applyAxisBox in reverse\n * and acts as a bridge between motion values and removeAxisDelta\n */\n\n\nfunction removeBoxTransforms(box, transforms) {\n  removeAxisTransforms(box.x, transforms, xKeys);\n  removeAxisTransforms(box.y, transforms, yKeys);\n}\n/**\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\n */\n\n\nfunction applyTreeDeltas(box, treeScale, treePath) {\n  treeScale.x = treeScale.y = 1;\n  var treeLength = treePath.length;\n\n  for (var i = 0; i < treeLength; i++) {\n    var parent_1 = treePath[i];\n    var delta = parent_1.delta;\n    applyBoxDelta(box, delta);\n    treeScale.x *= delta.x.scale;\n    treeScale.y *= delta.y.scale;\n  }\n}\n\nvar clampProgress = clamp(0, 1);\n/**\n * Returns true if the provided value is within maxDistance of the provided target\n */\n\nfunction isNear(value, target, maxDistance) {\n  if (target === void 0) {\n    target = 0;\n  }\n\n  if (maxDistance === void 0) {\n    maxDistance = 0.01;\n  }\n\n  return distance(value, target) < maxDistance;\n}\n/**\n * Calculate the translate needed to be applied to source to get target\n */\n\n\nfunction calcTranslate(source, target, origin) {\n  var sourcePoint = mix(source.min, source.max, origin);\n  var targetPoint = mix(target.min, target.max, origin);\n  return targetPoint - sourcePoint;\n}\n/**\n * Calculate a transform origin relative to the source axis, between 0-1, that results\n * in an asthetically pleasing scale/transform needed to project from source to target.\n */\n\n\nfunction calcOrigin(source, target) {\n  var origin = 0.5;\n  var sourceLength = source.max - source.min;\n  var targetLength = target.max - target.min;\n\n  if (targetLength > sourceLength) {\n    origin = progress(target.min, target.max - sourceLength, source.min);\n  } else if (sourceLength > targetLength) {\n    origin = progress(source.min, source.max - targetLength, target.min);\n  }\n\n  return clampProgress(origin);\n}\n/**\n * Update the AxisDelta with a transform that projects source into target.\n *\n * The transform `origin` is optional. If not provided, it'll be automatically\n * calculated based on the relative positions of the two bounding boxes.\n */\n\n\nfunction updateAxisDelta(delta, source, target, origin) {\n  var sourceLength = source.max - source.min;\n  var targetLength = target.max - target.min;\n  delta.origin = origin === undefined ? calcOrigin(source, target) : origin;\n  delta.originPoint = mix(source.min, source.max, delta.origin);\n  delta.scale = targetLength / sourceLength;\n  if (isNear(delta.scale, 1, 0.0001)) delta.scale = 1;\n  delta.translate = calcTranslate(source, target, delta.origin);\n  if (isNear(delta.translate)) delta.translate = 0;\n}\n/**\n * Update the BoxDelta with a transform that projects the source into the target.\n *\n * The transform `origin` is optional. If not provided, it'll be automatically\n * calculated based on the relative positions of the two bounding boxes.\n */\n\n\nfunction updateBoxDelta(delta, source, target, origin) {\n  updateAxisDelta(delta.x, source.x, target.x, origin);\n  updateAxisDelta(delta.y, source.y, target.y, origin);\n} // Call a handler once for each axis\n\n\nfunction eachAxis(handler) {\n  return [handler(\"x\"), handler(\"y\")];\n}\n\nvar isKeyframesTarget = function isKeyframesTarget(v) {\n  return Array.isArray(v);\n};\n\nvar underDampedSpring = function underDampedSpring() {\n  return {\n    type: \"spring\",\n    stiffness: 500,\n    damping: 25,\n    restDelta: 0.5,\n    restSpeed: 10\n  };\n};\n\nvar overDampedSpring = function overDampedSpring(to) {\n  return {\n    type: \"spring\",\n    stiffness: 700,\n    damping: to === 0 ? 100 : 35\n  };\n};\n\nvar linearTween = function linearTween() {\n  return {\n    ease: \"linear\",\n    duration: 0.3\n  };\n};\n\nvar keyframes = function keyframes(values) {\n  return {\n    type: \"keyframes\",\n    duration: 0.8,\n    values: values\n  };\n};\n\nvar defaultTransitions = {\n  x: underDampedSpring,\n  y: underDampedSpring,\n  z: underDampedSpring,\n  rotate: underDampedSpring,\n  rotateX: underDampedSpring,\n  rotateY: underDampedSpring,\n  rotateZ: underDampedSpring,\n  scaleX: overDampedSpring,\n  scaleY: overDampedSpring,\n  scale: overDampedSpring,\n  opacity: linearTween,\n  backgroundColor: linearTween,\n  color: linearTween,\n  \"default\": overDampedSpring\n};\n\nvar getDefaultTransition = function getDefaultTransition(valueKey, to) {\n  var transitionFactory;\n\n  if (isKeyframesTarget(to)) {\n    transitionFactory = keyframes;\n  } else {\n    transitionFactory = defaultTransitions[valueKey] || defaultTransitions[\"default\"];\n  }\n\n  return __assign({\n    to: to\n  }, transitionFactory(to));\n};\n/**\n * A Popmotion action that accepts a single `to` prop. When it starts, it immediately\n * updates with `to` and then completes. By using this we can compose instant transitions\n * in with the same logic that applies `delay` or returns a `Promise` etc.\n *\n * Accepting `duration` is a little bit of a hack that simply defers the completetion of\n * the animation until after the duration finishes. This is for situations when you're **only**\n * animating non-animatable values and then setting something on `transitionEnd`. Really\n * you want this to fire after the \"animation\" finishes, rather than instantly.\n *\n * ```\n * animate={{\n *   display: 'block',\n *   transitionEnd: { display: 'none' }\n * }}\n * ```\n */\n\n\nvar just = function just(_a) {\n  var to = _a.to,\n      duration = _a.duration;\n  return action(function (_a) {\n    var update = _a.update,\n        complete = _a.complete;\n    update(to);\n    duration ? delay(duration).start({\n      complete: complete\n    }) : complete();\n  });\n};\n\nvar easingDefinitionToFunction = function easingDefinitionToFunction(definition) {\n  if (Array.isArray(definition)) {\n    // If cubic bezier definition, create bezier curve\n    invariant(definition.length === 4, \"Cubic bezier arrays must contain four numerical values.\");\n    var x1 = definition[0],\n        y1 = definition[1],\n        x2 = definition[2],\n        y2 = definition[3];\n    return cubicBezier(x1, y1, x2, y2);\n  } else if (typeof definition === \"string\") {\n    // Else lookup from table\n    invariant(easingLookup[definition] !== undefined, \"Invalid easing type '\" + definition + \"'\");\n    return easingLookup[definition];\n  }\n\n  return definition;\n};\n\nvar isEasingArray = function isEasingArray(ease) {\n  return Array.isArray(ease) && typeof ease[0] !== \"number\";\n};\n\nvar isDurationAnimation = function isDurationAnimation(v) {\n  return v.hasOwnProperty(\"duration\") || v.hasOwnProperty(\"repeatDelay\");\n};\n/**\n * Check if a value is animatable. Examples:\n *\n * ✅: 100, \"100px\", \"#fff\"\n * ❌: \"block\", \"url(2.jpg)\"\n * @param value\n *\n * @internal\n */\n\n\nvar isAnimatable = function isAnimatable(key, value) {\n  // If the list of keys tat might be non-animatable grows, replace with Set\n  if (key === \"zIndex\") return false; // If it's a number or a keyframes array, we can animate it. We might at some point\n  // need to do a deep isAnimatable check of keyframes, or let Popmotion handle this,\n  // but for now lets leave it like this for performance reasons\n\n  if (typeof value === \"number\" || Array.isArray(value)) return true;\n\n  if (typeof value === \"string\" && // It's animatable if we have a string\n  complex.test(value) && // And it contains numbers and/or colors\n  !value.startsWith(\"url(\") // Unless it starts with \"url(\"\n  ) {\n      return true;\n    }\n\n  return false;\n};\n/**\n * Converts seconds to milliseconds\n *\n * @param seconds - Time in seconds.\n * @return milliseconds - Converted time in milliseconds.\n */\n\n\nvar secondsToMilliseconds = function secondsToMilliseconds(seconds) {\n  return seconds * 1000;\n};\n\nvar transitions = {\n  tween: tween,\n  spring: spring,\n  keyframes: keyframes$1,\n  inertia: inertia,\n  just: just\n};\nvar transitionOptionParser = {\n  tween: function tween(opts) {\n    if (opts.ease) {\n      var ease = isEasingArray(opts.ease) ? opts.ease[0] : opts.ease;\n      opts.ease = easingDefinitionToFunction(ease);\n    }\n\n    return opts;\n  },\n  keyframes: function keyframes(_a) {\n    var from = _a.from,\n        to = _a.to,\n        velocity = _a.velocity,\n        opts = __rest(_a, [\"from\", \"to\", \"velocity\"]);\n\n    if (opts.values && opts.values[0] === null) {\n      var values = __spreadArrays(opts.values);\n\n      values[0] = from;\n      opts.values = values;\n    }\n\n    if (opts.ease) {\n      opts.easings = isEasingArray(opts.ease) ? opts.ease.map(easingDefinitionToFunction) : easingDefinitionToFunction(opts.ease);\n    }\n\n    opts.ease = linear;\n    return opts;\n  }\n};\n\nvar isTransitionDefined = function isTransitionDefined(_a) {\n  var when = _a.when,\n      delay = _a.delay,\n      delayChildren = _a.delayChildren,\n      staggerChildren = _a.staggerChildren,\n      staggerDirection = _a.staggerDirection,\n      transition = __rest(_a, [\"when\", \"delay\", \"delayChildren\", \"staggerChildren\", \"staggerDirection\"]);\n\n  return Object.keys(transition).length;\n};\n\nvar getTransitionDefinition = function getTransitionDefinition(key, to, transitionDefinition) {\n  var delay = transitionDefinition ? transitionDefinition.delay : 0; // If no object, return default transition\n  // A better way to handle this would be to deconstruct out all the shared Orchestration props\n  // and see if there's any props remaining\n\n  if (transitionDefinition === undefined || !isTransitionDefined(transitionDefinition)) {\n    return __assign({\n      delay: delay\n    }, getDefaultTransition(key, to));\n  }\n\n  var valueTransitionDefinition = transitionDefinition[key] || transitionDefinition[\"default\"] || transitionDefinition;\n\n  if (valueTransitionDefinition.type === false) {\n    return {\n      delay: valueTransitionDefinition.hasOwnProperty(\"delay\") ? valueTransitionDefinition.delay : delay,\n      to: isKeyframesTarget(to) ? to[to.length - 1] : to,\n      type: \"just\"\n    };\n  } else if (isKeyframesTarget(to)) {\n    return __assign(__assign({\n      values: to,\n      duration: 0.8,\n      delay: delay,\n      ease: \"linear\"\n    }, valueTransitionDefinition), {\n      // This animation must be keyframes if we're animating through an array\n      type: \"keyframes\"\n    });\n  } else {\n    return __assign({\n      type: \"tween\",\n      to: to,\n      delay: delay\n    }, valueTransitionDefinition);\n  }\n};\n\nvar preprocessOptions = function preprocessOptions(type, opts) {\n  return transitionOptionParser[type] ? transitionOptionParser[type](opts) : opts;\n};\n\nvar getAnimation = function getAnimation(key, value, target, transition) {\n  var origin = value.get();\n  var isOriginAnimatable = isAnimatable(key, origin);\n  var isTargetAnimatable = isAnimatable(key, target); // TODO we could probably improve this check to ensure both values are of the same type -\n  // for instance 100 to #fff. This might live better in Popmotion.\n\n  warning(isOriginAnimatable === isTargetAnimatable, \"You are trying to animate \" + key + \" from \\\"\" + origin + \"\\\" to \\\"\" + target + \"\\\". \" + origin + \" is not an animatable value - to enable this animation set \" + origin + \" to a value animatable to \" + target + \" via the `style` property.\"); // Parse the `transition` prop and return options for the Popmotion animation\n\n  var _a = getTransitionDefinition(key, target, transition),\n      _b = _a.type,\n      type = _b === void 0 ? \"tween\" : _b,\n      transitionDefinition = __rest(_a, [\"type\"]); // If this is an animatable pair of values, return an animation, otherwise use `just`\n\n\n  var actionFactory = isOriginAnimatable && isTargetAnimatable ? transitions[type] : just;\n  var opts = preprocessOptions(type, __assign({\n    from: origin,\n    velocity: value.getVelocity()\n  }, transitionDefinition)); // Convert duration from Framer Motion's seconds into Popmotion's milliseconds\n\n  if (isDurationAnimation(opts)) {\n    if (opts.duration) {\n      opts.duration = secondsToMilliseconds(opts.duration);\n    }\n\n    if (opts.repeatDelay) {\n      opts.repeatDelay = secondsToMilliseconds(opts.repeatDelay);\n    }\n  }\n\n  return [actionFactory, opts];\n};\n/**\n * Start animation on a value. This function completely encapsulates Popmotion-specific logic.\n *\n * @internal\n */\n\n\nfunction startAnimation(key, value, target, _a) {\n  if (_a === void 0) {\n    _a = {};\n  }\n\n  var _b = _a.delay,\n      delay$1 = _b === void 0 ? 0 : _b,\n      transition = __rest(_a, [\"delay\"]);\n\n  return value.start(function (complete) {\n    var activeAnimation;\n\n    var _a = getAnimation(key, value, target, transition),\n        animationFactory = _a[0],\n        _b = _a[1],\n        valueDelay = _b.delay,\n        options = __rest(_b, [\"delay\"]);\n\n    if (valueDelay !== undefined) {\n      delay$1 = valueDelay;\n    }\n\n    var animate = function animate() {\n      var animation = animationFactory(options); // Bind animation opts to animation\n\n      activeAnimation = animation.start({\n        update: function update(v) {\n          return value.set(v);\n        },\n        complete: complete\n      });\n    }; // If we're delaying this animation, only resolve it **after** the delay to\n    // ensure the value's resolve velocity is up-to-date.\n\n\n    if (delay$1) {\n      activeAnimation = delay(secondsToMilliseconds(delay$1)).start({\n        complete: animate\n      });\n    } else {\n      animate();\n    }\n\n    return function () {\n      if (activeAnimation) activeAnimation.stop();\n    };\n  });\n}\n/**\n * Measure and return the element bounding box.\n *\n * We convert the box into an AxisBox2D to make it easier to work with each axis\n * individually and programmatically.\n *\n * This function optionally accepts a transformPagePoint function which allows us to compensate\n * for, for instance, measuring the element within a scaled plane like a Framer devivce preview component.\n */\n\n\nfunction getBoundingBox(element, transformPagePoint) {\n  var box = element.getBoundingClientRect();\n  return convertBoundingBoxToAxisBox(transformBoundingBox(box, transformPagePoint));\n}\n/**\n * A VisualElement for HTMLElements\n */\n\n\nvar HTMLVisualElement =\n/** @class */\nfunction (_super) {\n  __extends(HTMLVisualElement, _super);\n\n  function HTMLVisualElement() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\n     *\n     */\n\n\n    _this.defaultConfig = {\n      enableHardwareAcceleration: true,\n      allowTransformNone: true\n    };\n    /**\n     * A mutable record of styles we want to apply directly to the rendered Element\n     * every frame. We use a mutable data structure to reduce GC during animations.\n     */\n\n    _this.style = {};\n    /**\n     * A record of styles we only want to apply via React. This gets set in useMotionValues\n     * and applied in the render function. I'd prefer this to live somewhere else to decouple\n     * VisualElement from React but works for now.\n     */\n\n    _this.reactStyle = {};\n    /**\n     * A mutable record of CSS variables we want to apply directly to the rendered Element\n     * every frame. We use a mutable data structure to reduce GC during animations.\n     */\n\n    _this.vars = {};\n    /**\n     * A mutable record of transforms we want to apply directly to the rendered Element\n     * every frame. We use a mutable data structure to reduce GC during animations.\n     */\n\n    _this.transform = {};\n    /**\n     * A mutable record of transform origins we want to apply directly to the rendered Element\n     * every frame. We use a mutable data structure to reduce GC during animations.\n     */\n\n    _this.transformOrigin = {};\n    /**\n     * A mutable record of transform keys we want to apply to the rendered Element. We order\n     * this to order transforms in the desired order. We use a mutable data structure to reduce GC during animations.\n     */\n\n    _this.transformKeys = [];\n    _this.config = _this.defaultConfig;\n    /**\n     * ========================================\n     * Layout\n     * ========================================\n     */\n\n    _this.isLayoutProjectionEnabled = false;\n    /**\n     * A boolean that flags whether this component has children that need to be update\n     * when this component changes layout.\n     */\n\n    _this.hasLayoutChildren = false;\n    /**\n     * A set of layout update event handlers. These are only called once all layouts have been read,\n     * making it safe to perform DOM write operations.\n     */\n\n    _this.layoutUpdateListeners = new Set();\n    /**\n     * Keep track of whether the viewport box has been updated since the last render.\n     * If it has, we want to fire the onViewportBoxUpdate listener.\n     */\n\n    _this.hasViewportBoxUpdated = false;\n    /**\n     * The visual target we want to project our component into on a given frame\n     * before applying transforms defined in `animate` or `style`.\n     *\n     * This is considered mutable to avoid object creation on each frame.\n     */\n\n    _this.targetBoxFinal = axisBox();\n    /**\n     * The overall scale of the local coordinate system as transformed by all parents\n     * of this component. We use this for scale correction on our calculated layouts\n     * and scale-affected values like `boxShadow`.\n     *\n     * This is considered mutable to avoid object creation on each frame.\n     */\n\n    _this.treeScale = {\n      x: 1,\n      y: 1\n    };\n    /**\n     * The delta between the boxCorrected and the desired\n     * targetBox (before user-set transforms are applied). The calculated output will be\n     * handed to the renderer and used as part of the style correction calculations, for\n     * instance calculating how to display the desired border-radius correctly.\n     *\n     * This is considered mutable to avoid object creation on each frame.\n     */\n\n    _this.delta = delta();\n    /**\n     * The delta between the boxCorrected and the desired targetBoxFinal. The calculated\n     * output will be handed to the renderer and used to project the boxCorrected into\n     * the targetBoxFinal.\n     *\n     * This is considered mutable to avoid object creation on each frame.\n     */\n\n    _this.deltaFinal = delta();\n    /**\n     *\n     */\n\n    _this.stopLayoutAxisAnimation = {\n      x: function x() {},\n      y: function y() {}\n    };\n    _this.isTargetBoxLocked = false;\n    /**\n     *\n     */\n\n    _this.axisProgress = {\n      x: motionValue(0),\n      y: motionValue(0)\n    };\n    return _this;\n  }\n  /**\n   * When a value is removed, we want to make sure it's removed from all rendered data structures.\n   */\n\n\n  HTMLVisualElement.prototype.removeValue = function (key) {\n    _super.prototype.removeValue.call(this, key);\n\n    delete this.vars[key];\n    delete this.style[key];\n  };\n  /**\n   * Empty the mutable data structures by re-creating them. We can do this every React render\n   * as the comparative workload to the rest of the render is very low and this is also when\n   * we want to reflect values that might have been removed by the render.\n   */\n\n\n  HTMLVisualElement.prototype.clean = function () {\n    this.style = {};\n    this.vars = {};\n    this.transform = {};\n  };\n\n  HTMLVisualElement.prototype.updateConfig = function (config) {\n    if (config === void 0) {\n      config = {};\n    }\n\n    this.config = __assign(__assign({}, this.defaultConfig), config);\n  };\n  /**\n   * Read a value directly from the HTMLElement style.\n   */\n\n\n  HTMLVisualElement.prototype.read = function (key) {\n    return this.getComputedStyle()[key] || 0;\n  };\n  /**\n   * Read a value directly from the HTMLElement in case it's not defined by a Motion\n   * prop. If it's a transform, we just return a pre-defined default value as reading these\n   * out of a matrix is either error-prone or can incur a big payload for little benefit.\n   */\n\n\n  HTMLVisualElement.prototype.readNativeValue = function (key) {\n    if (isTransformProp(key)) {\n      var defaultValueType = getDefaultValueType(key);\n      return defaultValueType ? defaultValueType[\"default\"] || 0 : 0;\n    } else {\n      return this.read(key);\n    }\n  };\n\n  HTMLVisualElement.prototype.enableLayoutProjection = function () {\n    this.isLayoutProjectionEnabled = true;\n    forEachParent(this, function (parent) {\n      return parent.hasLayoutChildren = true;\n    });\n  };\n\n  HTMLVisualElement.prototype.hide = function () {\n    if (this.isVisible === false) return;\n    this.isVisible = false;\n    this.scheduleRender();\n  };\n\n  HTMLVisualElement.prototype.show = function () {\n    if (this.isVisible === true) return;\n    this.isVisible = true;\n    this.scheduleRender();\n  };\n  /**\n   * Register an event listener to fire when the layout is updated. We might want to expose support\n   * for this via a `motion` prop.\n   */\n\n\n  HTMLVisualElement.prototype.onLayoutUpdate = function (callback) {\n    var _this = this;\n\n    this.layoutUpdateListeners.add(callback);\n    return function () {\n      return _this.layoutUpdateListeners[\"delete\"](callback);\n    };\n  };\n  /**\n   * To be called when all layouts are successfully updated. In turn we can notify layoutUpdate\n   * subscribers.\n   */\n\n\n  HTMLVisualElement.prototype.layoutReady = function (config) {\n    var _this = this;\n\n    this.layoutUpdateListeners.forEach(function (listener) {\n      listener(_this.box, _this.prevViewportBox || _this.box, config);\n    });\n  };\n  /**\n   * Measure and return the Element's bounding box. We convert it to a AxisBox2D\n   * structure to make it easier to work on each individual axis generically.\n   */\n\n\n  HTMLVisualElement.prototype.getBoundingBox = function () {\n    var transformPagePoint = this.config.transformPagePoint;\n    return getBoundingBox(this.element, transformPagePoint);\n  };\n\n  HTMLVisualElement.prototype.getBoundingBoxWithoutTransforms = function () {\n    var bbox = this.getBoundingBox();\n    removeBoxTransforms(bbox, this.latest);\n    return bbox;\n  };\n  /**\n   * Return the computed style after a render.\n   */\n\n\n  HTMLVisualElement.prototype.getComputedStyle = function () {\n    return window.getComputedStyle(this.element);\n  };\n  /**\n   *\n   */\n\n\n  HTMLVisualElement.prototype.snapshotBoundingBox = function () {\n    this.prevViewportBox = this.getBoundingBoxWithoutTransforms();\n    /**\n     * Update targetBox to match the prevViewportBox. This is just to ensure\n     * that targetBox is affected by scroll in the same way as the measured box\n     */\n\n    var _a = this.axisProgress,\n        x = _a.x,\n        y = _a.y;\n\n    if (!this.isTargetBoxLocked && !x.isAnimating() && !y.isAnimating()) {\n      this.targetBox = copyAxisBox(this.prevViewportBox);\n    }\n  };\n\n  HTMLVisualElement.prototype.measureLayout = function () {\n    this.box = this.getBoundingBox();\n    this.boxCorrected = copyAxisBox(this.box);\n    if (!this.targetBox) this.targetBox = copyAxisBox(this.box);\n  };\n  /**\n   * Ensure the targetBox reflects the latest visual box on screen\n   */\n\n\n  HTMLVisualElement.prototype.refreshTargetBox = function () {\n    this.targetBox = this.getBoundingBoxWithoutTransforms();\n  };\n\n  HTMLVisualElement.prototype.lockTargetBox = function () {\n    this.isTargetBoxLocked = true;\n  };\n\n  HTMLVisualElement.prototype.unlockTargetBox = function () {\n    this.stopLayoutAnimation();\n    this.isTargetBoxLocked = false;\n  };\n  /**\n   * Reset the transform on the current Element. This is called as part\n   * of a batched process across the entire layout tree. To remove this write\n   * cycle it'd be interesting to see if it's possible to \"undo\" all the current\n   * layout transforms up the tree in the same way this.getBoundingBoxWithoutTransforms\n   * works\n   */\n\n\n  HTMLVisualElement.prototype.resetTransform = function () {\n    this.element.style.transform = \"none\"; // Ensure that whatever happens next, we restore our transform\n\n    this.scheduleRender();\n  };\n  /**\n   * Set new min/max boundaries to project an axis into\n   */\n\n\n  HTMLVisualElement.prototype.setAxisTarget = function (axis, min, max) {\n    var targetAxis = this.targetBox[axis];\n    targetAxis.min = min;\n    targetAxis.max = max; // Flag that we want to fire the onViewportBoxUpdate event handler\n\n    this.hasViewportBoxUpdated = true;\n    /**\n     * If this component re-renders we need to ensure that any children performing\n     * layout projection also update\n     *\n     * TODO: This recursively traverses all children for each axis and for each component. A performance\n     * improvement would be to:\n     *  1. Flag the root component as dirty and schedule it to update pre-render\n     *  2. Recursively traverse tree from root layout component during this update\n     *      scheduling renders and updating deltas\n     */\n\n    scheduleChildrenLayoutRender(this);\n  };\n  /**\n   *\n   */\n\n\n  HTMLVisualElement.prototype.startLayoutAxisAnimation = function (axis, transition) {\n    var _this = this;\n\n    var progress = this.axisProgress[axis];\n    var _a = this.targetBox[axis],\n        min = _a.min,\n        max = _a.max;\n    var length = max - min;\n    progress.clearListeners();\n    progress.set(min);\n    progress.set(min); // Set twice to hard-reset velocity\n\n    progress.onChange(function (v) {\n      return _this.setAxisTarget(axis, v, v + length);\n    });\n    return startAnimation(axis, progress, 0, transition);\n  };\n\n  HTMLVisualElement.prototype.stopLayoutAnimation = function () {\n    var _this = this;\n\n    eachAxis(function (axis) {\n      return _this.axisProgress[axis].stop();\n    });\n  };\n  /**\n   * Update the layout deltas to reflect the relative positions of the layout\n   * and the desired target box\n   */\n\n\n  HTMLVisualElement.prototype.updateLayoutDeltas = function (isReactRender) {\n    var _a, _b;\n    /**\n     * Ensure that all the parent deltas are up-to-date before calculating this delta.\n     *\n     * TODO: This approach is exceptionally wasteful as every child will update\n     * the deltas of its parent even if it's already updated for this frame.\n     * We can optimise this by replacing this to a call directly to the root VisualElement\n     * which then runs iteration from the top-down, but only once per framestamp.\n     */\n\n\n    this.treePath.forEach(function (p) {\n      return p.updateLayoutDeltas(isReactRender);\n    });\n    /**\n     * Early return if layout reprojection isn't enabled\n     */\n\n    if (!this.isLayoutProjectionEnabled || !this.box) return;\n    /**\n     * Reset the corrected box with the latest values from box, as we're then going\n     * to perform mutative operations on it.\n     */\n\n    resetBox(this.boxCorrected, this.box);\n    /**\n     * Apply all the parent deltas to this box to produce the corrected box. This\n     * is the layout box, as it will appear on screen as a result of the transforms of its parents.\n     */\n\n    applyTreeDeltas(this.boxCorrected, this.treeScale, this.treePath);\n    /**\n     * Apply the latest user-set transforms to the targetBox to produce the targetBoxFinal.\n     * This is the final box that we will then project into by calculating a transform delta and\n     * applying it to the corrected box.\n     */\n\n    applyBoxTransforms(this.targetBoxFinal, this.targetBox, this.latest);\n    /**\n     * Update the delta between the corrected box and the target box before user-set transforms were applied.\n     * This will allow us to calculate the corrected borderRadius and boxShadow to compensate\n     * for our layout reprojection, but still allow them to be scaled correctly by the user.\n     * It might be that to simplify this we may want to accept that user-set scale is also corrected\n     * and we wouldn't have to keep and calc both deltas, OR we could support a user setting\n     * to allow people to choose whether these styles are corrected based on just the\n     * layout reprojection or the final bounding box.\n     */\n\n    updateBoxDelta(this.delta, this.boxCorrected, this.targetBox);\n    /**\n     * Update the delta between the corrected box and the final target box, after\n     * user-set transforms are applied to it. This will be used by the renderer to\n     * create a transform style that will reproject the element from its actual layout\n     * into the desired bounding box.\n     */\n\n    updateBoxDelta(this.deltaFinal, this.boxCorrected, this.targetBoxFinal);\n    /**\n     * If we have a listener for the viewport box, fire it.\n     * TODO: Instead of manually checking this, use framesync postRender\n     */\n\n    if (!isReactRender) {\n      this.hasViewportBoxUpdated && ((_b = (_a = this.config).onViewportBoxUpdate) === null || _b === void 0 ? void 0 : _b.call(_a, this.targetBox, this.delta));\n      this.hasViewportBoxUpdated = false;\n    }\n  };\n  /**\n   * ========================================\n   * Build & render\n   * ========================================\n   */\n\n  /**\n   * Build a style prop using the latest resolved MotionValues\n   */\n\n\n  HTMLVisualElement.prototype.build = function (isReactRender) {\n    if (this.isVisible !== undefined) {\n      this.style.visibility = this.isVisible ? \"visible\" : \"hidden\";\n    }\n\n    this.isLayoutProjectionEnabled && this.box && this.updateLayoutDeltas(isReactRender);\n    buildHTMLStyles(this.latest, this.style, this.vars, this.transform, this.transformOrigin, this.transformKeys, this.config, this.isLayoutProjectionEnabled && !!this.box, this.delta, this.deltaFinal, this.treeScale, this.targetBoxFinal);\n  };\n  /**\n   * Render the Element by rebuilding and applying the latest styles and vars.\n   */\n\n\n  HTMLVisualElement.prototype.render = function () {\n    // Rebuild the latest animated values into style and vars caches.\n    this.build(false); // Directly assign style into the Element's style prop. In tests Object.assign is the\n    // fastest way to assign styles.\n\n    Object.assign(this.element.style, this.style); // Loop over any CSS variables and assign those.\n\n    for (var key in this.vars) {\n      this.element.style.setProperty(key, this.vars[key]);\n    }\n  };\n\n  return HTMLVisualElement;\n}(VisualElement);\n\nfunction scheduleChildrenLayoutRender(element) {\n  if (element.isLayoutProjectionEnabled) {\n    element.scheduleRender();\n  }\n\n  if (element.hasLayoutChildren) {\n    element.children.forEach(scheduleChildrenLayoutRender);\n  }\n}\n\nfunction forEachParent(child, callback) {\n  var parent = child.parent;\n\n  while (parent) {\n    callback(parent);\n    parent = parent.parent;\n  }\n}\n/**\n * Creates a constant value over the lifecycle of a component.\n *\n * Even if `useMemo` is provided an empty array as its final argument, it doesn't offer\n * a guarantee that it won't re-run for performance reasons later on. By using `useConstant`\n * you can ensure that initialisers don't execute twice or more.\n */\n\n\nfunction useConstant(init) {\n  var ref = useRef(null);\n\n  if (ref.current === null) {\n    ref.current = init();\n  }\n\n  return ref.current;\n}\n\nfunction calcOrigin$1(origin, offset, size) {\n  return typeof origin === \"string\" ? origin : px.transform(offset + size * origin);\n}\n/**\n * The SVG transform origin defaults are different to CSS and is less intuitive,\n * so we use the measured dimensions of the SVG to reconcile these.\n */\n\n\nfunction calcSVGTransformOrigin(dimensions, originX, originY) {\n  var pxOriginX = calcOrigin$1(originX, dimensions.x, dimensions.width);\n  var pxOriginY = calcOrigin$1(originY, dimensions.y, dimensions.height);\n  return pxOriginX + \" \" + pxOriginY;\n} // Convert a progress 0-1 to a pixels value based on the provided length\n\n\nvar progressToPixels = function progressToPixels(progress, length) {\n  return px.transform(progress * length);\n};\n\nvar dashKeys = {\n  offset: \"stroke-dashoffset\",\n  array: \"stroke-dasharray\"\n};\nvar camelKeys = {\n  offset: \"strokeDashoffset\",\n  array: \"strokeDasharray\"\n};\n/**\n * Build SVG path properties. Uses the path's measured length to convert\n * our custom pathLength, pathSpacing and pathOffset into stroke-dashoffset\n * and stroke-dasharray attributes.\n *\n * This function is mutative to reduce per-frame GC.\n */\n\nfunction buildSVGPath(attrs, totalLength, length, spacing, offset, useDashCase) {\n  if (spacing === void 0) {\n    spacing = 1;\n  }\n\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  if (useDashCase === void 0) {\n    useDashCase = true;\n  } // We use dash case when setting attributes directly to the DOM node and camel case\n  // when defining props on a React component.\n\n\n  var keys = useDashCase ? dashKeys : camelKeys; // Build the dash offset\n\n  attrs[keys.offset] = progressToPixels(-offset, totalLength); // Build the dash array\n\n  var pathLength = progressToPixels(length, totalLength);\n  var pathSpacing = progressToPixels(spacing, totalLength);\n  attrs[keys.array] = pathLength + \" \" + pathSpacing;\n}\n\nvar unmeasured = {\n  x: 0,\n  y: 0,\n  width: 0,\n  height: 0\n};\n/**\n * Build SVG visual attrbutes, like cx and style.transform\n */\n\nfunction buildSVGAttrs(_a, style, vars, attrs, transform, transformOrigin, transformKeys, config, dimensions, totalPathLength) {\n  var attrX = _a.attrX,\n      attrY = _a.attrY,\n      originX = _a.originX,\n      originY = _a.originY,\n      pathLength = _a.pathLength,\n      _b = _a.pathSpacing,\n      pathSpacing = _b === void 0 ? 1 : _b,\n      _c = _a.pathOffset,\n      pathOffset = _c === void 0 ? 0 : _c,\n      // This is object creation, which we try to avoid per-frame.\n  latest = __rest(_a, [\"attrX\", \"attrY\", \"originX\", \"originY\", \"pathLength\", \"pathSpacing\", \"pathOffset\"]);\n  /**\n   * With SVG we treat all animated values as attributes rather than CSS, so we build into attrs\n   */\n\n\n  buildHTMLStyles(latest, attrs, vars, transform, transformOrigin, transformKeys, config);\n  /**\n   * However, we apply transforms as CSS transforms. So if we detect a transform we take it from attrs\n   * and copy it into style.\n   */\n\n  if (attrs.transform) {\n    style.transform = attrs.transform;\n    delete attrs.transform;\n  } // Parse transformOrigin\n\n\n  if (originX !== undefined || originY !== undefined || style.transform) {\n    style.transformOrigin = calcSVGTransformOrigin(dimensions || unmeasured, originX !== undefined ? originX : 0.5, originY !== undefined ? originY : 0.5);\n  } // Treat x/y not as shortcuts but as actual attributes\n\n\n  if (attrX !== undefined) attrs.x = attrX;\n  if (attrY !== undefined) attrs.y = attrY; // Build SVG path if one has been measured\n\n  if (totalPathLength !== undefined && pathLength !== undefined) {\n    buildSVGPath(attrs, totalPathLength, pathLength, pathSpacing, pathOffset, false);\n  }\n\n  return attrs;\n}\n/**\n * A set of attribute names that are always read/written as camel case.\n */\n\n\nvar camelCaseAttributes = new Set([\"baseFrequency\", \"diffuseConstant\", \"kernelMatrix\", \"kernelUnitLength\", \"keySplines\", \"keyTimes\", \"limitingConeAngle\", \"markerHeight\", \"markerWidth\", \"numOctaves\", \"targetX\", \"targetY\", \"surfaceScale\", \"specularConstant\", \"specularExponent\", \"stdDeviation\", \"tableValues\"]);\nvar CAMEL_CASE_PATTERN = /([a-z])([A-Z])/g;\nvar REPLACE_TEMPLATE = \"$1-$2\";\n/**\n * Convert camelCase to dash-case properties.\n */\n\nvar camelToDash = function camelToDash(str) {\n  return str.replace(CAMEL_CASE_PATTERN, REPLACE_TEMPLATE).toLowerCase();\n};\n/**\n * A VisualElement for SVGElements. Inherits from and extends HTMLVisualElement as the two\n * share data structures.\n */\n\n\nvar SVGVisualElement =\n/** @class */\nfunction (_super) {\n  __extends(SVGVisualElement, _super);\n\n  function SVGVisualElement() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\n     * A mutable record of attributes we want to apply directly to the rendered Element\n     * every frame. We use a mutable data structure to reduce GC during animations.\n     */\n\n\n    _this.attrs = {};\n    /**\n     * We disable hardware acceleration for SVG transforms as they're not currently able to be accelerated.\n     */\n\n    _this.defaultConfig = {\n      enableHardwareAcceleration: false\n    };\n    /**\n     * Without duplicating this call from HTMLVisualElement we end up with HTMLVisualElement.defaultConfig\n     * being assigned to config\n     */\n\n    _this.config = _this.defaultConfig;\n    return _this;\n  }\n  /**\n   * Measure the SVG element on mount. This can affect page rendering so there might be a\n   * better time to perform this - for instance dynamically only if there's a transform-origin dependent\n   * transform being set (like rotate)\n   */\n\n\n  SVGVisualElement.prototype.mount = function (element) {\n    _super.prototype.mount.call(this, element);\n\n    this.measure();\n  };\n  /**\n   * Update the SVG dimensions and path length\n   */\n\n\n  SVGVisualElement.prototype.measure = function () {\n    try {\n      this.dimensions = typeof this.element.getBBox === \"function\" ? this.element.getBBox() : this.element.getBoundingClientRect();\n    } catch (e) {\n      // Most likely trying to measure an unrendered element under Firefox\n      this.dimensions = {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n      };\n    }\n\n    if (isPath(this.element)) {\n      this.totalPathLength = this.element.getTotalLength();\n    }\n  };\n  /**\n   * Empty the mutable data structures in case attrs have been removed between renders.\n   */\n\n\n  SVGVisualElement.prototype.clean = function () {\n    _super.prototype.clean.call(this);\n\n    this.attrs = {};\n  };\n  /**\n   * Read an attribute directly from the SVGElement\n   */\n\n\n  SVGVisualElement.prototype.read = function (key) {\n    key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;\n    return this.element.getAttribute(key);\n  };\n\n  SVGVisualElement.prototype.build = function () {\n    buildSVGAttrs(this.latest, this.style, this.vars, this.attrs, this.transform, this.transformOrigin, this.transformKeys, this.config, this.dimensions, this.totalPathLength);\n  };\n\n  SVGVisualElement.prototype.render = function () {\n    // Update HTML styles and CSS variables\n    _super.prototype.render.call(this); // Loop through attributes and apply them to the SVGElement\n\n\n    for (var key in this.attrs) {\n      this.element.setAttribute(camelToDash(key), this.attrs[key]);\n    }\n  };\n\n  return SVGVisualElement;\n}(HTMLVisualElement);\n\nfunction isPath(element) {\n  return element.tagName === \"path\";\n}\n/**\n * @internal\n */\n\n/**\n * @internal\n */\n\n\nvar svgElements = [\"animate\", \"circle\", \"clipPath\", \"defs\", \"desc\", \"ellipse\", \"feBlend\", \"feColorMatrix\", \"feComponentTransfer\", \"feComposite\", \"feConvolveMatrix\", \"feDiffuseLighting\", \"feDisplacementMap\", \"feDistantLight\", \"feDropShadow\", \"feFlood\", \"feFuncA\", \"feFuncB\", \"feFuncG\", \"feFuncR\", \"feGaussianBlur\", \"feImage\", \"feMerge\", \"feMergeNode\", \"feMorphology\", \"feOffset\", \"fePointLight\", \"feSpecularLighting\", \"feSpotLight\", \"feTile\", \"feTurbulence\", \"filter\", \"foreignObject\", \"g\", \"image\", \"line\", \"linearGradient\", \"marker\", \"mask\", \"metadata\", \"path\", \"pattern\", \"polygon\", \"polyline\", \"radialGradient\", \"rect\", \"stop\", \"svg\", \"switch\", \"symbol\", \"text\", \"textPath\", \"tspan\", \"use\", \"view\"];\nvar svgTagNames = new Set(svgElements);\n/**\n * Determine whether this is a HTML or SVG component based on if the provided\n * Component is a string and a recognised SVG tag. A potentially better way to\n * do this would be to offer a `motion.customSVG` function and determine this\n * when we generate the `motion.circle` etc components.\n */\n\nfunction isSVGComponent(Component) {\n  return typeof Component === \"string\" && svgTagNames.has(Component);\n}\n/**\n * @public\n */\n\n\nvar PresenceContext = createContext(null);\n/**\n * When a component is the child of `AnimatePresence`, it can use `usePresence`\n * to access information about whether it's still present in the React tree.\n *\n * ```jsx\n * import { usePresence } from \"framer-motion\"\n *\n * export const Component = () => {\n *   const [isPresent, safeToRemove] = usePresence()\n *\n *   useEffect(() => {\n *     !isPresent setTimeout(safeToRemove, 1000)\n *   }, [isPresent])\n *\n *   return <div />\n * }\n * ```\n *\n * If `isPresent` is `false`, it means that a component has been removed the tree, but\n * `AnimatePresence` won't really remove it until `safeToRemove` has been called.\n *\n * @public\n */\n\nfunction usePresence() {\n  var context = useContext(PresenceContext);\n  if (context === null) return [true, null];\n  var isPresent = context.isPresent,\n      onExitComplete = context.onExitComplete,\n      register = context.register; // It's safe to call the following hooks conditionally (after an early return) because the context will always\n  // either be null or non-null for the lifespan of the component.\n  // Replace with useOpaqueId when released in React\n\n  var id = useUniqueId();\n  useEffect(function () {\n    return register(id);\n  }, []);\n\n  var safeToRemove = function safeToRemove() {\n    return onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete(id);\n  };\n\n  return !isPresent && onExitComplete ? [false, safeToRemove] : [true];\n}\n/**\n * @public\n */\n\n\nfunction useIsPresent() {\n  var context = useContext(PresenceContext);\n  return context === null ? true : context.isPresent;\n}\n\nvar counter = 0;\n\nvar incrementId = function incrementId() {\n  return counter++;\n};\n\nvar useUniqueId = function useUniqueId() {\n  return useConstant(incrementId);\n};\n/**\n * DOM-flavoured variation of the useVisualElement hook. Used to create either a HTMLVisualElement\n * or SVGVisualElement for the component.\n */\n\n\nvar useDomVisualElement = function useDomVisualElement(Component, props, parent, isStatic, ref) {\n  var visualElement = useConstant(function () {\n    var DOMVisualElement = isSVGComponent(Component) ? SVGVisualElement : HTMLVisualElement;\n    return new DOMVisualElement(parent, ref);\n  });\n  visualElement.updateConfig(__assign({\n    enableHardwareAcceleration: !isStatic\n  }, props));\n  visualElement.layoutId = props.layoutId;\n  var isPresent = useIsPresent();\n  visualElement.isPresent = props.isPresent !== undefined ? props.isPresent : isPresent;\n  return visualElement;\n};\n/**\n * A list of all valid MotionProps.\n *\n * @internalremarks\n * This doesn't throw if a `MotionProp` name is missing - it should.\n */\n\n\nvar validMotionProps = new Set([\"initial\", \"animate\", \"exit\", \"style\", \"variants\", \"transition\", \"transformTemplate\", \"transformValues\", \"custom\", \"inherit\", \"static\", \"layout\", \"layoutId\", \"onLayoutAnimationComplete\", \"onViewportBoxUpdate\", \"onAnimationStart\", \"onAnimationComplete\", \"onUpdate\", \"onDragStart\", \"onDrag\", \"onDragEnd\", \"onMeasureDragConstraints\", \"onDirectionLock\", \"onDragTransitionEnd\", \"drag\", \"dragControls\", \"dragListener\", \"dragConstraints\", \"dragDirectionLock\", \"dragElastic\", \"dragMomentum\", \"dragPropagation\", \"dragTransition\", \"onPan\", \"onPanStart\", \"onPanEnd\", \"onPanSessionStart\", \"onTap\", \"onTapStart\", \"onTapCancel\", \"whileHover\", \"whileTap\", \"onHoverEnd\", \"onHoverStart\"]);\n/**\n * Check whether a prop name is a valid `MotionProp` key.\n *\n * @param key - Name of the property to check\n * @returns `true` is key is a valid `MotionProp`.\n *\n * @public\n */\n\nfunction isValidMotionProp(key) {\n  return validMotionProps.has(key);\n}\n\nvar isPropValid = function isPropValid(key) {\n  return !isValidMotionProp(key);\n};\n/**\n * Emotion and Styled Components both allow users to pass through arbitrary props to their components\n * to dynamically generate CSS. They both use the `@emotion/is-prop-valid` package to determine which\n * of these should be passed to the underlying DOM node.\n *\n * However, when styling a Motion component `styled(motion.div)`, both packages pass through *all* props\n * as it's seen as an arbitrary component rather than a DOM node. Motion only allows arbitrary props\n * passed through the `custom` prop so it doesn't *need* the payload or computational overhead of\n * `@emotion/is-prop-valid`, however to fix this problem we need to use it.\n *\n * By making it an optionalDependency we can offer this functionality only in the situations where it's\n * actually required.\n */\n\n\ntry {\n  var emotionIsPropValid_1 = require(\"@emotion/is-prop-valid\")[\"default\"];\n\n  isPropValid = function isPropValid(key) {\n    // Handle events explicitly as Emotion validates them all as true\n    if (key.startsWith(\"on\")) {\n      return !isValidMotionProp(key);\n    } else {\n      return emotionIsPropValid_1(key);\n    }\n  };\n} catch (_a) {// We don't need to actually do anything here - the fallback is the existing `isPropValid`.\n}\n\nfunction filterProps(props) {\n  var domProps = {};\n\n  for (var key in props) {\n    if (isPropValid(key)) domProps[key] = props[key];\n  }\n\n  return domProps;\n}\n\nfunction buildHTMLProps(visualElement, _a) {\n  var drag = _a.drag; // The `any` isn't ideal but it is the type of createElement props argument\n\n  var htmlProps = {\n    style: __assign(__assign(__assign({}, visualElement.reactStyle), visualElement.style), visualElement.vars)\n  };\n\n  if (!!drag) {\n    // Disable text selection\n    htmlProps.style.userSelect = \"none\"; // Disable the ghost element when a user drags\n\n    htmlProps.draggable = false;\n  }\n\n  return htmlProps;\n}\n/**\n * Build React props for SVG elements\n */\n\n\nfunction buildSVGProps(visualElement) {\n  return __assign(__assign({}, visualElement.attrs), {\n    style: __assign({}, visualElement.reactStyle)\n  });\n}\n\nfunction render(Component, props, visualElement) {\n  // Only filter props from components we control, ie `motion.div`. If this\n  // is a custom component pass along everything provided to it.\n  var forwardedProps = typeof Component === \"string\" ? filterProps(props) : props;\n  /**\n   * Every render, empty and rebuild the animated values to be applied to our Element.\n   * During animation these data structures are used in a mutable fashion to reduce\n   * garbage collection, but between renders we can flush them to remove values\n   * that might have been taken out of the provided props.\n   */\n\n  visualElement.clean();\n  visualElement.build(true); // Generate props to visually render this component\n\n  var visualProps = isSVGComponent(Component) ? buildSVGProps(visualElement) : buildHTMLProps(visualElement, props);\n  return createElement(Component, __assign(__assign(__assign({}, forwardedProps), {\n    ref: visualElement.ref\n  }), visualProps));\n}\n\nfunction isCSSVariable$1(value) {\n  return typeof value === \"string\" && value.startsWith(\"var(--\");\n}\n/**\n * Parse Framer's special CSS variable format into a CSS token and a fallback.\n *\n * ```\n * `var(--foo, #fff)` => [`--foo`, '#fff']\n * ```\n *\n * @param current\n */\n\n\nvar cssVariableRegex = /var\\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\\)/;\n\nfunction parseCSSVariable(current) {\n  var match = cssVariableRegex.exec(current);\n  if (!match) return [,];\n  var token = match[1],\n      fallback = match[2];\n  return [token, fallback];\n}\n\nvar maxDepth = 4;\n\nfunction getVariableValue(current, element, depth) {\n  if (depth === void 0) {\n    depth = 1;\n  }\n\n  invariant(depth <= maxDepth, \"Max CSS variable fallback depth detected in property \\\"\" + current + \"\\\". This may indicate a circular fallback dependency.\");\n\n  var _a = parseCSSVariable(current),\n      token = _a[0],\n      fallback = _a[1]; // No CSS variable detected\n\n\n  if (!token) return; // Attempt to read this CSS variable off the element\n\n  var resolved = window.getComputedStyle(element).getPropertyValue(token);\n\n  if (resolved) {\n    return resolved;\n  } else if (isCSSVariable$1(fallback)) {\n    // The fallback might itself be a CSS variable, in which case we attempt to resolve it too.\n    return getVariableValue(fallback, element, depth + 1);\n  } else {\n    return fallback;\n  }\n}\n/**\n * Resolve CSS variables from\n *\n * @internal\n */\n\n\nfunction resolveCSSVariables(visualElement, _a, transitionEnd) {\n  var target = __rest(_a, []);\n\n  var element = visualElement.getInstance();\n  if (!(element instanceof HTMLElement)) return {\n    target: target,\n    transitionEnd: transitionEnd\n  }; // If `transitionEnd` isn't `undefined`, clone it. We could clone `target` and `transitionEnd`\n  // only if they change but I think this reads clearer and this isn't a performance-critical path.\n\n  if (transitionEnd) {\n    transitionEnd = __assign({}, transitionEnd);\n  } // Go through existing `MotionValue`s and ensure any existing CSS variables are resolved\n\n\n  visualElement.forEachValue(function (value) {\n    var current = value.get();\n    if (!isCSSVariable$1(current)) return;\n    var resolved = getVariableValue(current, element);\n    if (resolved) value.set(resolved);\n  }); // Cycle through every target property and resolve CSS variables. Currently\n  // we only read single-var properties like `var(--foo)`, not `calc(var(--foo) + 20px)`\n\n  for (var key in target) {\n    var current = target[key];\n    if (!isCSSVariable$1(current)) continue;\n    var resolved = getVariableValue(current, element);\n    if (!resolved) continue; // Clone target if it hasn't already been\n\n    target[key] = resolved; // If the user hasn't already set this key on `transitionEnd`, set it to the unresolved\n    // CSS variable. This will ensure that after the animation the component will reflect\n    // changes in the value of the CSS variable.\n\n    if (transitionEnd && transitionEnd[key] === undefined) {\n      transitionEnd[key] = current;\n    }\n  }\n\n  return {\n    target: target,\n    transitionEnd: transitionEnd\n  };\n}\n\nvar positionalKeys = new Set([\"width\", \"height\", \"top\", \"left\", \"right\", \"bottom\", \"x\", \"y\"]);\n\nvar isPositionalKey = function isPositionalKey(key) {\n  return positionalKeys.has(key);\n};\n\nvar hasPositionalKey = function hasPositionalKey(target) {\n  return Object.keys(target).some(isPositionalKey);\n};\n\nvar setAndResetVelocity = function setAndResetVelocity(value, to) {\n  // Looks odd but setting it twice doesn't render, it'll just\n  // set both prev and current to the latest value\n  value.set(to, false);\n  value.set(to);\n};\n\nvar isNumOrPxType = function isNumOrPxType(v) {\n  return v === number || v === px;\n};\n\nvar BoundingBoxDimension;\n\n(function (BoundingBoxDimension) {\n  BoundingBoxDimension[\"width\"] = \"width\";\n  BoundingBoxDimension[\"height\"] = \"height\";\n  BoundingBoxDimension[\"left\"] = \"left\";\n  BoundingBoxDimension[\"right\"] = \"right\";\n  BoundingBoxDimension[\"top\"] = \"top\";\n  BoundingBoxDimension[\"bottom\"] = \"bottom\";\n})(BoundingBoxDimension || (BoundingBoxDimension = {}));\n\nvar getPosFromMatrix = function getPosFromMatrix(matrix, pos) {\n  return parseFloat(matrix.split(\", \")[pos]);\n};\n\nvar getTranslateFromMatrix = function getTranslateFromMatrix(pos2, pos3) {\n  return function (_bbox, _a) {\n    var transform = _a.transform;\n    if (transform === \"none\" || !transform) return 0;\n    var matrix3d = transform.match(/^matrix3d\\((.+)\\)$/);\n\n    if (matrix3d) {\n      return getPosFromMatrix(matrix3d[1], pos3);\n    } else {\n      var matrix = transform.match(/^matrix\\((.+)\\)$/);\n\n      if (matrix) {\n        return getPosFromMatrix(matrix[1], pos2);\n      } else {\n        return 0;\n      }\n    }\n  };\n};\n\nvar transformKeys = new Set([\"x\", \"y\", \"z\"]);\nvar nonTranslationalTransformKeys = transformProps.filter(function (key) {\n  return !transformKeys.has(key);\n});\n\nfunction removeNonTranslationalTransform(visualElement) {\n  var removedTransforms = [];\n  nonTranslationalTransformKeys.forEach(function (key) {\n    var value = visualElement.getValue(key);\n\n    if (value !== undefined) {\n      removedTransforms.push([key, value.get()]);\n      value.set(key.startsWith(\"scale\") ? 1 : 0);\n    }\n  }); // Apply changes to element before measurement\n\n  if (removedTransforms.length) visualElement.render();\n  return removedTransforms;\n}\n\nvar positionalValues = {\n  // Dimensions\n  width: function width(_a) {\n    var x = _a.x;\n    return x.max - x.min;\n  },\n  height: function height(_a) {\n    var y = _a.y;\n    return y.max - y.min;\n  },\n  top: function top(_bbox, _a) {\n    var top = _a.top;\n    return parseFloat(top);\n  },\n  left: function left(_bbox, _a) {\n    var left = _a.left;\n    return parseFloat(left);\n  },\n  bottom: function bottom(_a, _b) {\n    var y = _a.y;\n    var top = _b.top;\n    return parseFloat(top) + (y.max - y.min);\n  },\n  right: function right(_a, _b) {\n    var x = _a.x;\n    var left = _b.left;\n    return parseFloat(left) + (x.max - x.min);\n  },\n  // Transform\n  x: getTranslateFromMatrix(4, 13),\n  y: getTranslateFromMatrix(5, 14)\n};\n\nvar convertChangedValueTypes = function convertChangedValueTypes(target, visualElement, changedKeys) {\n  var originBbox = visualElement.getBoundingBox();\n  var elementComputedStyle = visualElement.getComputedStyle();\n  var display = elementComputedStyle.display,\n      top = elementComputedStyle.top,\n      left = elementComputedStyle.left,\n      bottom = elementComputedStyle.bottom,\n      right = elementComputedStyle.right,\n      transform = elementComputedStyle.transform;\n  var originComputedStyle = {\n    top: top,\n    left: left,\n    bottom: bottom,\n    right: right,\n    transform: transform\n  }; // If the element is currently set to display: \"none\", make it visible before\n  // measuring the target bounding box\n\n  if (display === \"none\") {\n    visualElement.setStaticValues(\"display\", target.display || \"block\");\n  } // Apply the latest values (as set in checkAndConvertChangedValueTypes)\n\n\n  visualElement.render();\n  var targetBbox = visualElement.getBoundingBox();\n  changedKeys.forEach(function (key) {\n    // Restore styles to their **calculated computed style**, not their actual\n    // originally set style. This allows us to animate between equivalent pixel units.\n    var value = visualElement.getValue(key);\n    setAndResetVelocity(value, positionalValues[key](originBbox, originComputedStyle));\n    target[key] = positionalValues[key](targetBbox, elementComputedStyle);\n  });\n  return target;\n};\n\nvar checkAndConvertChangedValueTypes = function checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd) {\n  if (origin === void 0) {\n    origin = {};\n  }\n\n  if (transitionEnd === void 0) {\n    transitionEnd = {};\n  }\n\n  target = __assign({}, target);\n  transitionEnd = __assign({}, transitionEnd);\n  var targetPositionalKeys = Object.keys(target).filter(isPositionalKey); // We want to remove any transform values that could affect the element's bounding box before\n  // it's measured. We'll reapply these later.\n\n  var removedTransformValues = [];\n  var hasAttemptedToRemoveTransformValues = false;\n  var changedValueTypeKeys = [];\n  targetPositionalKeys.forEach(function (key) {\n    var value = visualElement.getValue(key);\n    if (!visualElement.hasValue(key)) return;\n    var from = origin[key];\n    var to = target[key];\n    var fromType = findDimensionValueType(from);\n    var toType; // TODO: The current implementation of this basically throws an error\n    // if you try and do value conversion via keyframes. There's probably\n    // a way of doing this but the performance implications would need greater scrutiny,\n    // as it'd be doing multiple resize-remeasure operations.\n\n    if (isKeyframesTarget(to)) {\n      var numKeyframes = to.length;\n\n      for (var i = to[0] === null ? 1 : 0; i < numKeyframes; i++) {\n        if (!toType) {\n          toType = findDimensionValueType(to[i]);\n          invariant(toType === fromType || isNumOrPxType(fromType) && isNumOrPxType(toType), \"Keyframes must be of the same dimension as the current value\");\n        } else {\n          invariant(findDimensionValueType(to[i]) === toType, \"All keyframes must be of the same type\");\n        }\n      }\n    } else {\n      toType = findDimensionValueType(to);\n    }\n\n    if (fromType !== toType) {\n      // If they're both just number or px, convert them both to numbers rather than\n      // relying on resize/remeasure to convert (which is wasteful in this situation)\n      if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {\n        var current = value.get();\n\n        if (typeof current === \"string\") {\n          value.set(parseFloat(current));\n        }\n\n        if (typeof to === \"string\") {\n          target[key] = parseFloat(to);\n        } else if (Array.isArray(to) && toType === px) {\n          target[key] = to.map(parseFloat);\n        }\n      } else {\n        // If we're going to do value conversion via DOM measurements, we first\n        // need to remove non-positional transform values that could affect the bbox measurements.\n        if (!hasAttemptedToRemoveTransformValues) {\n          removedTransformValues = removeNonTranslationalTransform(visualElement);\n          hasAttemptedToRemoveTransformValues = true;\n        }\n\n        changedValueTypeKeys.push(key);\n        transitionEnd[key] = transitionEnd[key] !== undefined ? transitionEnd[key] : target[key];\n        setAndResetVelocity(value, to);\n      }\n    }\n  });\n\n  if (changedValueTypeKeys.length) {\n    var convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys); // If we removed transform values, reapply them before the next render\n\n    if (removedTransformValues.length) {\n      removedTransformValues.forEach(function (_a) {\n        var key = _a[0],\n            value = _a[1];\n        visualElement.getValue(key).set(value);\n      });\n    } // Reapply original values\n\n\n    visualElement.render();\n    return {\n      target: convertedTarget,\n      transitionEnd: transitionEnd\n    };\n  } else {\n    return {\n      target: target,\n      transitionEnd: transitionEnd\n    };\n  }\n};\n/**\n * Convert value types for x/y/width/height/top/left/bottom/right\n *\n * Allows animation between `'auto'` -> `'100%'` or `0` -> `'calc(50% - 10vw)'`\n *\n * @internal\n */\n\n\nfunction unitConversion(visualElement, target, origin, transitionEnd) {\n  return hasPositionalKey(target) ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd) : {\n    target: target,\n    transitionEnd: transitionEnd\n  };\n}\n/**\n * Parse a DOM variant to make it animatable. This involves resolving CSS variables\n * and ensuring animations like \"20%\" => \"calc(50vw)\" are performed in pixels.\n */\n\n\nvar parseDomVariant = function parseDomVariant(visualElement, target, origin, transitionEnd) {\n  var resolved = resolveCSSVariables(visualElement, target, transitionEnd);\n  target = resolved.target;\n  transitionEnd = resolved.transitionEnd;\n  return unitConversion(visualElement, target, origin, transitionEnd);\n};\n/**\n * Use callback either only on the initial render or on all renders. In concurrent mode\n * the \"initial\" render might run multiple times\n *\n * @param callback - Callback to run\n * @param isInitialOnly - Set to `true` to only run on initial render, or `false` for all renders. Defaults to `false`.\n *\n * @public\n */\n\n\nfunction useInitialOrEveryRender(callback, isInitialOnly) {\n  if (isInitialOnly === void 0) {\n    isInitialOnly = false;\n  }\n\n  var isInitialRender = useRef(true);\n\n  if (!isInitialOnly || isInitialOnly && isInitialRender.current) {\n    callback();\n  }\n\n  isInitialRender.current = false;\n}\n/**\n * Control animations on one or more components.\n *\n * @public\n */\n\n\nvar AnimationControls =\n/** @class */\nfunction () {\n  function AnimationControls() {\n    /**\n     * Track whether the host component has mounted.\n     *\n     * @internal\n     */\n    this.hasMounted = false;\n    /**\n     * Pending animations that are started before a component is mounted.\n     *\n     * @internal\n     */\n\n    this.pendingAnimations = [];\n    /**\n     * A collection of linked component animation controls.\n     *\n     * @internal\n     */\n\n    this.componentControls = new Set();\n  }\n  /**\n   * Set variants on this and all child components.\n   *\n   * @param variants - The variants to set\n   *\n   * @internal\n   */\n\n\n  AnimationControls.prototype.setVariants = function (variants) {\n    this.variants = variants;\n    this.componentControls.forEach(function (controls) {\n      return controls.setVariants(variants);\n    });\n  };\n  /**\n   * Set a default transition on this and all child components\n   *\n   * @param transition - The default transition to set\n   *\n   * @internal\n   */\n\n\n  AnimationControls.prototype.setDefaultTransition = function (transition) {\n    this.defaultTransition = transition;\n    this.componentControls.forEach(function (controls) {\n      return controls.setDefaultTransition(transition);\n    });\n  };\n  /**\n   * Subscribes a component's animation controls to this.\n   *\n   * @param controls - The controls to subscribe\n   * @returns An unsubscribe function.\n   *\n   * @internal\n   */\n\n\n  AnimationControls.prototype.subscribe = function (controls) {\n    var _this = this;\n\n    this.componentControls.add(controls);\n    if (this.variants) controls.setVariants(this.variants);\n    if (this.defaultTransition) controls.setDefaultTransition(this.defaultTransition);\n    return function () {\n      return _this.componentControls[\"delete\"](controls);\n    };\n  };\n  /**\n   * Starts an animation on all linked components.\n   *\n   * @remarks\n   *\n   * ```jsx\n   * controls.start(\"variantLabel\")\n   * controls.start({\n   *   x: 0,\n   *   transition: { duration: 1 }\n   * })\n   * ```\n   *\n   * @param definition - Properties or variant label to animate to\n   * @param transition - Optional `transtion` to apply to a variant\n   * @returns - A `Promise` that resolves when all animations have completed.\n   *\n   * @public\n   */\n\n\n  AnimationControls.prototype.start = function (definition, transitionOverride) {\n    var _this = this;\n\n    if (this.hasMounted) {\n      var animations_1 = [];\n      this.componentControls.forEach(function (controls) {\n        var animation = controls.start(definition, {\n          transitionOverride: transitionOverride\n        });\n        animations_1.push(animation);\n      });\n      return Promise.all(animations_1);\n    } else {\n      return new Promise(function (resolve) {\n        _this.pendingAnimations.push({\n          animation: [definition, transitionOverride],\n          resolve: resolve\n        });\n      });\n    }\n  };\n  /**\n   * Instantly set to a set of properties or a variant.\n   *\n   * ```jsx\n   * // With properties\n   * controls.set({ opacity: 0 })\n   *\n   * // With variants\n   * controls.set(\"hidden\")\n   * ```\n   *\n   * @internalremarks\n   * We could perform a similar trick to `.start` where this can be called before mount\n   * and we maintain a list of of pending actions that get applied on mount. But the\n   * expectation of `set` is that it happens synchronously and this would be difficult\n   * to do before any children have even attached themselves. It's also poor practise\n   * and we should discourage render-synchronous `.start` calls rather than lean into this.\n   *\n   * @public\n   */\n\n\n  AnimationControls.prototype.set = function (definition) {\n    invariant(this.hasMounted, \"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n    return this.componentControls.forEach(function (controls) {\n      return controls.apply(definition);\n    });\n  };\n  /**\n   * Stops animations on all linked components.\n   *\n   * ```jsx\n   * controls.stop()\n   * ```\n   *\n   * @public\n   */\n\n\n  AnimationControls.prototype.stop = function () {\n    this.componentControls.forEach(function (controls) {\n      return controls.stop();\n    });\n  };\n  /**\n   * Initialises the animation controls.\n   *\n   * @internal\n   */\n\n\n  AnimationControls.prototype.mount = function () {\n    var _this = this;\n\n    this.hasMounted = true;\n    this.pendingAnimations.forEach(function (_a) {\n      var animation = _a.animation,\n          resolve = _a.resolve;\n      return _this.start.apply(_this, animation).then(resolve);\n    });\n  };\n  /**\n   * Stops all child animations when the host component unmounts.\n   *\n   * @internal\n   */\n\n\n  AnimationControls.prototype.unmount = function () {\n    this.hasMounted = false;\n    this.stop();\n  };\n\n  return AnimationControls;\n}();\n/**\n * @internal\n */\n\n\nvar animationControls = function animationControls() {\n  return new AnimationControls();\n};\n/**\n * @internal\n */\n\n\nvar MotionContext = createContext({\n  \"static\": false\n});\n\nvar isVariantLabel = function isVariantLabel(v) {\n  return typeof v === \"string\" || Array.isArray(v);\n};\n\nvar isAnimationControls = function isAnimationControls(v) {\n  return v instanceof AnimationControls;\n};\n/**\n * Set up the context for children motion components.\n *\n * We also use this opportunity to apply `initial` values\n */\n\n\nvar useMotionContext = function useMotionContext(parentContext, controls, visualElement, isStatic, _a) {\n  if (isStatic === void 0) {\n    isStatic = false;\n  }\n\n  var initial = _a.initial,\n      animate = _a.animate,\n      variants = _a.variants,\n      whileTap = _a.whileTap,\n      whileHover = _a.whileHover,\n      layoutId = _a.layoutId; // Determine whether this is a root element of an AnimatePresence component\n\n  var presenceContext = useContext(PresenceContext);\n  var presenceId = presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.id;\n  visualElement.isPresenceRoot = parentContext.presenceId !== presenceId; // Override initial with that from a parent context, if defined\n\n  if ((presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.initial) !== undefined) {\n    initial = presenceContext.initial;\n  }\n\n  var initialState;\n\n  if (initial === false && !isAnimationControls(animate)) {\n    initialState = animate;\n  } else if (typeof initial !== \"boolean\") {\n    initialState = initial;\n  } // Track mounted status so children can detect whether they were present during their\n  // parent's first render\n\n\n  var hasMounted = useRef(false); // We propagate this component's VisualElementAnimationControls *if* we're being provided variants,\n  // if we're being used to control variants, or if we're being passed animation controls.\n  // Otherwise this component should be \"invisible\" to variant propagation. This is a slight concession\n  // to Framer X where every `Frame` is a `motion` component and it might be if we change that in the future\n  // that this restriction is removed.\n\n  var shouldPropagateControls = variants || isVariantLabel(animate) || isVariantLabel(whileTap) || isVariantLabel(whileHover) || isAnimationControls(animate); // If this component's `initial` prop is a variant label, propagate it. Otherwise pass the parent's.\n\n  var targetInitial = isVariantLabel(initialState) ? initialState : parentContext.initial; // If this is a variant tree we need to propagate the `animate` prop in case new children are added after\n  // the tree initially animates.\n\n  var targetAnimate = isVariantLabel(animate) ? animate : parentContext.animate; // Only allow `initial` to trigger context re-renders if this is a `static` component (ie we're on the Framer canvas)\n  // or in another non-animation/interaction environment.\n\n  var initialDependency = isStatic ? targetInitial : null; // Only allow `animate` to trigger context re-renders if it's a variant label. If this is an array of\n  // variant labels there's probably an optimisation to deep-compare but it might be an over-optimisation.\n  // We want to do this as we rely on React's component rendering order each render cycle to determine\n  // the new order of any child components for the `staggerChildren` functionality.\n\n  var animateDependency = shouldPropagateControls && isVariantLabel(targetAnimate) ? targetAnimate : null; // The context to provide to the child. We `useMemo` because although `controls` and `initial` are\n  // unlikely to change, by making the context an object it'll be considered a new value every render.\n  // So all child motion components will re-render as a result.\n\n  var context = useMemo(function () {\n    return {\n      controls: shouldPropagateControls ? controls : parentContext.controls,\n      initial: targetInitial,\n      animate: targetAnimate,\n      visualElement: visualElement,\n      hasMounted: hasMounted,\n      isReducedMotion: parentContext.isReducedMotion,\n      presenceId: presenceId\n    };\n  }, [initialDependency, animateDependency, parentContext.isReducedMotion, animate, layoutId, presenceId]); // Update the `static` property every render. This is unlikely to change but also essentially free.\n\n  context[\"static\"] = isStatic; // Set initial state. If this is a static component (ie in Framer canvas), respond to updates\n  // in `initial`.\n\n  useInitialOrEveryRender(function () {\n    var initialToApply = initialState || parentContext.initial;\n    initialToApply && controls.apply(initialToApply);\n  }, !isStatic);\n  useEffect(function () {\n    hasMounted.current = true;\n  }, []);\n  return context;\n};\n\nvar checkShouldInheritVariant = function checkShouldInheritVariant(_a) {\n  var animate = _a.animate,\n      variants = _a.variants,\n      _b = _a.inherit,\n      inherit = _b === void 0 ? true : _b;\n  return inherit && !!variants && (!animate || animate instanceof AnimationControls);\n};\n\nvar isMotionValue = function isMotionValue(value) {\n  return value instanceof MotionValue;\n};\n/**\n * Scrape props for MotionValues and add/remove them to this component's\n * VisualElement\n */\n\n\nfunction useMotionValues(visualElement, props) {\n  var prev = useConstant(empty);\n  /**\n   * Remove MotionValues that are no longer present\n   */\n\n  for (var key in prev) {\n    var isTransform = isTransformProp(key) || isTransformOriginProp(key);\n    var existsAsProp = props[key];\n    var existsAsStyle = props.style && props.style[key];\n    var propIsMotionValue = existsAsProp && isMotionValue(props[key]);\n    var styleIsMotionValue = existsAsStyle && isMotionValue(props.style[key]);\n    var transformRemoved = isTransform && !existsAsProp && !existsAsStyle;\n    var motionValueRemoved = !isTransform && !propIsMotionValue && !styleIsMotionValue;\n\n    if (transformRemoved || motionValueRemoved) {\n      visualElement.removeValue(key);\n      delete prev[key];\n    }\n  }\n  /**\n   * Add incoming MotionValues\n   */\n\n\n  addMotionValues(visualElement, prev, props);\n  if (props.style) addMotionValues(visualElement, prev, props.style, true);\n  /**\n   * Transform custom values if provided a handler, ie size -> width/height\n   * Ideally we'd ditch this by removing support for size and other custom values from Framer.\n   */\n\n  if (props.transformValues) {\n    visualElement.reactStyle = props.transformValues(visualElement.reactStyle);\n  }\n}\n/**\n * Add incoming MotionValues\n *\n * TODO: Type the VisualElements properly\n */\n\n\nfunction addMotionValues(visualElement, prev, source, isStyle) {\n  if (isStyle === void 0) {\n    isStyle = false;\n  }\n\n  if (isStyle) visualElement.reactStyle = {};\n\n  for (var key in source) {\n    var value = source[key];\n    var foundMotionValue = false;\n\n    if (isMotionValue(value)) {\n      // If this is a MotionValue, add it if it isn't a reserved key\n      if (!reservedNames.has(key)) {\n        visualElement.addValue(key, value);\n        foundMotionValue = true;\n      }\n    } else if (isTransformProp(key) || isTransformOriginProp(key)) {\n      // If this is a transform prop, always create a MotionValue\n      // to ensure we can reconcile them all together.\n      if (!visualElement.hasValue(key)) {\n        visualElement.addValue(key, motionValue(value));\n      } else if (value !== prev[key]) {\n        // If the MotionValue already exists, update it with the\n        // latest incoming value\n        var motion = visualElement.getValue(key);\n        motion.set(value);\n      }\n\n      foundMotionValue = true;\n    } else if (isStyle) {\n      visualElement.reactStyle[key] = value;\n    }\n\n    if (foundMotionValue) prev[key] = value;\n  }\n}\n/**\n * These are props we accept as MotionValues but don't want to add\n * to the VisualElement\n */\n\n\nvar reservedNames = new Set([]);\n\nvar empty = function empty() {\n  return {};\n};\n\nvar isCustomValue = function isCustomValue(v) {\n  return Boolean(v && typeof v === \"object\" && v.mix && v.toValue);\n};\n\nvar resolveFinalValueInKeyframes = function resolveFinalValueInKeyframes(v) {\n  // TODO maybe throw if v.length - 1 is placeholder token?\n  return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;\n};\n/**\n * Check if value is a numerical string, ie a string that is purely a number eg \"100\" or \"-100.1\"\n */\n\n\nvar isNumericalString = function isNumericalString(v) {\n  return /^\\-?\\d*\\.?\\d+$/.test(v);\n};\n/**\n * Get the current value of every `MotionValue` in a `VisualElement`\n */\n\n\nvar getCurrent = function getCurrent(visualElement) {\n  var current = {};\n  visualElement.forEachValue(function (value, key) {\n    return current[key] = value.get();\n  });\n  return current;\n};\n/**\n * Get the current velocity of every `MotionValue` in a `VisualElement`\n */\n\n\nvar getVelocity = function getVelocity(visualElement) {\n  var velocity = {};\n  visualElement.forEachValue(function (value, key) {\n    return velocity[key] = value.getVelocity();\n  });\n  return velocity;\n};\n/**\n * Check if value is a function that returns a `Target`. A generic typeof === 'function'\n * check, just helps with typing.\n */\n\n\nvar isTargetResolver = function isTargetResolver(p) {\n  return typeof p === \"function\";\n};\n/**\n * Check if value is a list of variant labels\n */\n\n\nvar isVariantLabels = function isVariantLabels(v) {\n  return Array.isArray(v);\n};\n/**\n * Control animations for a single component\n *\n * @internal\n */\n\n\nvar VisualElementAnimationControls =\n/** @class */\nfunction () {\n  function VisualElementAnimationControls(visualElement, _a) {\n    var _this = this;\n\n    var makeTargetAnimatable = _a.makeTargetAnimatable;\n    /**\n     * A reference to the component's latest props. We could probably ditch this in\n     * favour to a reference to the `custom` prop now we don't send all props through\n     * to target resolvers.\n     */\n\n    this.props = {};\n    /**\n     * The component's variants, as provided by `variants`\n     */\n\n    this.variants = {};\n    /**\n     * A set of values that we animate back to when a value is cleared of all overrides.\n     */\n\n    this.baseTarget = {};\n    /**\n     * A series of target overrides that we can animate to/from when overrides are set/cleared.\n     */\n\n    this.overrides = [];\n    /**\n     * A series of target overrides as they were originally resolved.\n     */\n\n    this.resolvedOverrides = [];\n    /**\n     * A Set of currently active override indexes\n     */\n\n    this.activeOverrides = new Set();\n    /**\n     * A Set of value keys that are currently animating.\n     */\n\n    this.isAnimating = new Set();\n    /**\n     * Check if the associated `VisualElement` has a key with the provided string.\n     * Pre-bound to the class so we can provide directly to the `filter` in `checkForNewValues`.\n     */\n\n    this.hasValue = function (key) {\n      return !_this.visualElement.hasValue(key);\n    };\n\n    this.visualElement = visualElement;\n    this.makeTargetAnimatable = makeTargetAnimatable;\n    this.visualElement.forEachValue(function (value, key) {\n      return _this.baseTarget[key] = value.get();\n    });\n  }\n  /**\n   * Set the reference to the component's props.\n   * @param props -\n   */\n\n\n  VisualElementAnimationControls.prototype.setProps = function (props) {\n    this.props = props;\n  };\n  /**\n   * Set the reference to the component's variants\n   * @param variants -\n   */\n\n\n  VisualElementAnimationControls.prototype.setVariants = function (variants) {\n    if (variants) this.variants = variants;\n  };\n  /**\n   * Set the component's default transition\n   * @param transition -\n   */\n\n\n  VisualElementAnimationControls.prototype.setDefaultTransition = function (transition) {\n    if (transition) this.defaultTransition = transition;\n  };\n  /**\n   * Set motion values without animation.\n   *\n   * @param definition -\n   * @param isActive -\n   */\n\n\n  VisualElementAnimationControls.prototype.setValues = function (definition, _a) {\n    var _b = _a === void 0 ? {} : _a,\n        _c = _b.isActive,\n        isActive = _c === void 0 ? new Set() : _c,\n        priority = _b.priority;\n\n    var _d = this.resolveVariant(definition),\n        target = _d.target,\n        transitionEnd = _d.transitionEnd;\n\n    target = this.transformValues(__assign(__assign({}, target), transitionEnd));\n\n    for (var key in target) {\n      if (isActive.has(key)) return;\n      isActive.add(key);\n\n      if (target) {\n        var targetValue = resolveFinalValueInKeyframes(target[key]);\n\n        if (this.visualElement.hasValue(key)) {\n          var value = this.visualElement.getValue(key);\n          value && value.set(targetValue);\n        } else {\n          this.visualElement.addValue(key, motionValue(targetValue));\n        }\n\n        if (!priority) this.baseTarget[key] = targetValue;\n      }\n    }\n  };\n  /**\n   * Allows `transformValues` to be set by a component that allows us to\n   * transform the values in a given `Target`. This allows Framer Library\n   * to extend Framer Motion to animate `Color` variables etc. Currently we have\n   * to manually support these extended types here in Framer Motion.\n   *\n   * @param values -\n   */\n\n\n  VisualElementAnimationControls.prototype.transformValues = function (values) {\n    var transformValues = this.props.transformValues;\n    return transformValues ? transformValues(values) : values;\n  };\n  /**\n   * Check a `Target` for new values we haven't animated yet, and add them\n   * to the `MotionValueMap`.\n   *\n   * Currently there's functionality here that is DOM-specific, we should allow\n   * this functionality to be injected by the factory that creates DOM-specific\n   * components.\n   *\n   * @param target -\n   */\n\n\n  VisualElementAnimationControls.prototype.checkForNewValues = function (target) {\n    var newValueKeys = Object.keys(target).filter(this.hasValue);\n    var numNewValues = newValueKeys.length;\n    if (!numNewValues) return;\n\n    for (var i = 0; i < numNewValues; i++) {\n      var key = newValueKeys[i];\n      var targetValue = target[key];\n      var value = null; // If this is a keyframes value, we can attempt to use the first value in the\n      // array as that's going to be the first value of the animation anyway\n\n      if (Array.isArray(targetValue)) {\n        value = targetValue[0];\n      } // If it isn't a keyframes or the first keyframes value was set as `null`, read the\n      // value from the DOM. It might be worth investigating whether to check props (for SVG)\n      // or props.style (for HTML) if the value exists there before attempting to read.\n\n\n      if (value === null) {\n        var readValue = this.visualElement.readNativeValue(key);\n        value = readValue !== undefined ? readValue : target[key];\n        invariant(value !== null, \"No initial value for \\\"\" + key + \"\\\" can be inferred. Ensure an initial value for \\\"\" + key + \"\\\" is defined on the component.\");\n      }\n\n      if (typeof value === \"string\" && isNumericalString(value)) {\n        // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\n        value = parseFloat(value);\n      } else if (!findValueType(value) && complex.test(targetValue)) {\n        // If value is not recognised as animatable, ie \"none\", create an animatable version origin based on the target\n        value = complex.getAnimatableNone(targetValue);\n      }\n\n      this.visualElement.addValue(key, motionValue(value));\n      this.baseTarget[key] = value;\n    }\n  };\n  /**\n   * Resolve a variant from its label or resolver into an actual `Target` we can animate to.\n   * @param variant -\n   */\n\n\n  VisualElementAnimationControls.prototype.resolveVariant = function (variant) {\n    if (!variant) {\n      return {\n        target: undefined,\n        transition: undefined,\n        transitionEnd: undefined\n      };\n    }\n\n    if (isTargetResolver(variant)) {\n      // resolve current and velocity\n      variant = variant(this.props.custom, getCurrent(this.visualElement), getVelocity(this.visualElement));\n    }\n\n    var _a = variant.transition,\n        transition = _a === void 0 ? this.defaultTransition : _a,\n        transitionEnd = variant.transitionEnd,\n        target = __rest(variant, [\"transition\", \"transitionEnd\"]);\n\n    return {\n      transition: transition,\n      transitionEnd: transitionEnd,\n      target: target\n    };\n  };\n  /**\n   * Get the highest active override priority index\n   */\n\n\n  VisualElementAnimationControls.prototype.getHighestPriority = function () {\n    if (!this.activeOverrides.size) return 0;\n    return Math.max.apply(Math, Array.from(this.activeOverrides));\n  };\n  /**\n   * Set an override. We add this layer of indirection so if, for instance, a tap gesture\n   * starts and overrides a hover gesture, when we clear the tap gesture and fallback to the\n   * hover gesture, if that hover gesture has changed in the meantime we can go to that rather\n   * than the one that was resolved when the hover gesture animation started.\n   *\n   * @param definition -\n   * @param overrideIndex -\n   */\n\n\n  VisualElementAnimationControls.prototype.setOverride = function (definition, overrideIndex) {\n    this.overrides[overrideIndex] = definition;\n\n    if (this.children) {\n      this.children.forEach(function (child) {\n        return child.setOverride(definition, overrideIndex);\n      });\n    }\n  };\n  /**\n   * Start an override animation.\n   * @param overrideIndex -\n   */\n\n\n  VisualElementAnimationControls.prototype.startOverride = function (overrideIndex) {\n    var override = this.overrides[overrideIndex];\n\n    if (override) {\n      return this.start(override, {\n        priority: overrideIndex\n      });\n    }\n  };\n  /**\n   * Clear an override. We check every value we animated to in this override to see if\n   * its present on any lower-priority overrides. If not, we animate it back to its base target.\n   * @param overrideIndex -\n   */\n\n\n  VisualElementAnimationControls.prototype.clearOverride = function (overrideIndex) {\n    var _this = this;\n\n    if (this.children) {\n      this.children.forEach(function (child) {\n        return child.clearOverride(overrideIndex);\n      });\n    }\n\n    var override = this.overrides[overrideIndex];\n    if (!override) return;\n    this.activeOverrides[\"delete\"](overrideIndex);\n    var highest = this.getHighestPriority();\n    this.resetIsAnimating();\n\n    if (highest) {\n      var highestOverride = this.overrides[highest];\n      highestOverride && this.startOverride(highest);\n    } // Figure out which remaining values were affected by the override and animate those\n\n\n    var overrideTarget = this.resolvedOverrides[overrideIndex];\n    if (!overrideTarget) return;\n    var remainingValues = {};\n\n    for (var key in this.baseTarget) {\n      if (overrideTarget[key] !== undefined) {\n        remainingValues[key] = this.baseTarget[key];\n      }\n    }\n\n    this.onStart();\n    this.animate(remainingValues).then(function () {\n      return _this.onComplete();\n    });\n  };\n  /**\n   * Apply a target/variant without any animation\n   */\n\n\n  VisualElementAnimationControls.prototype.apply = function (definition) {\n    if (Array.isArray(definition)) {\n      return this.applyVariantLabels(definition);\n    } else if (typeof definition === \"string\") {\n      return this.applyVariantLabels([definition]);\n    } else {\n      this.setValues(definition);\n    }\n  };\n  /**\n   * Apply variant labels without animation\n   */\n\n\n  VisualElementAnimationControls.prototype.applyVariantLabels = function (variantLabelList) {\n    var _this = this;\n\n    var isActive = new Set();\n\n    var reversedList = __spreadArrays(variantLabelList).reverse();\n\n    reversedList.forEach(function (key) {\n      var _a = _this.resolveVariant(_this.variants[key]),\n          target = _a.target,\n          transitionEnd = _a.transitionEnd;\n\n      if (transitionEnd) {\n        _this.setValues(transitionEnd, {\n          isActive: isActive\n        });\n      }\n\n      if (target) {\n        _this.setValues(target, {\n          isActive: isActive\n        });\n      }\n\n      if (_this.children && _this.children.size) {\n        _this.children.forEach(function (child) {\n          return child.applyVariantLabels(variantLabelList);\n        });\n      }\n    });\n  };\n\n  VisualElementAnimationControls.prototype.start = function (definition, opts) {\n    var _this = this;\n\n    if (opts === void 0) {\n      opts = {};\n    }\n\n    if (opts.priority) {\n      this.activeOverrides.add(opts.priority);\n    }\n\n    this.resetIsAnimating(opts.priority);\n    var animation;\n\n    if (isVariantLabels(definition)) {\n      animation = this.animateVariantLabels(definition, opts);\n    } else if (typeof definition === \"string\") {\n      animation = this.animateVariant(definition, opts);\n    } else {\n      animation = this.animate(definition, opts);\n    }\n\n    this.onStart();\n    return animation.then(function () {\n      return _this.onComplete();\n    });\n  };\n\n  VisualElementAnimationControls.prototype.animate = function (animationDefinition, _a) {\n    var _this = this;\n\n    var _b = _a === void 0 ? {} : _a,\n        _c = _b.delay,\n        delay = _c === void 0 ? 0 : _c,\n        _d = _b.priority,\n        priority = _d === void 0 ? 0 : _d,\n        transitionOverride = _b.transitionOverride;\n\n    var _e = this.resolveVariant(animationDefinition),\n        target = _e.target,\n        transition = _e.transition,\n        transitionEnd = _e.transitionEnd;\n\n    if (transitionOverride) {\n      transition = transitionOverride;\n    }\n\n    if (!target) return Promise.resolve();\n    target = this.transformValues(target);\n\n    if (transitionEnd) {\n      transitionEnd = this.transformValues(transitionEnd);\n    }\n\n    this.checkForNewValues(target);\n    var origin = this.transformValues(getOrigin(target, transition, this.visualElement));\n\n    if (this.makeTargetAnimatable) {\n      var animatable = this.makeTargetAnimatable(this.visualElement, target, origin, transitionEnd);\n      target = animatable.target;\n      transitionEnd = animatable.transitionEnd;\n    }\n\n    if (priority) {\n      this.resolvedOverrides[priority] = target;\n    }\n\n    this.checkForNewValues(target);\n    var animations = [];\n\n    for (var key in target) {\n      var value = this.visualElement.getValue(key);\n      if (!value || !target || target[key] === undefined) continue;\n      var valueTarget = target[key];\n\n      if (!priority) {\n        this.baseTarget[key] = resolveFinalValueInKeyframes(valueTarget);\n      }\n\n      if (this.isAnimating.has(key)) continue;\n      this.isAnimating.add(key);\n      animations.push(startAnimation(key, value, valueTarget, __assign({\n        delay: delay\n      }, transition)));\n    }\n\n    var allAnimations = Promise.all(animations);\n    return transitionEnd ? allAnimations.then(function () {\n      _this.setValues(transitionEnd, {\n        priority: priority\n      });\n    }) : allAnimations;\n  };\n\n  VisualElementAnimationControls.prototype.animateVariantLabels = function (variantLabels, opts) {\n    var _this = this;\n\n    var animations = __spreadArrays(variantLabels).reverse().map(function (label) {\n      return _this.animateVariant(label, opts);\n    });\n\n    return Promise.all(animations);\n  };\n\n  VisualElementAnimationControls.prototype.animateVariant = function (variantLabel, opts) {\n    var _this = this;\n\n    var when = false;\n    var delayChildren = 0;\n    var staggerChildren = 0;\n    var staggerDirection = 1;\n    var priority = opts && opts.priority || 0;\n    var variant = this.variants[variantLabel];\n    var getAnimations = variant ? function () {\n      return _this.animate(variant, opts);\n    } : function () {\n      return Promise.resolve();\n    };\n    var getChildrenAnimations = this.children ? function () {\n      return _this.animateChildren(variantLabel, delayChildren, staggerChildren, staggerDirection, priority);\n    } : function () {\n      return Promise.resolve();\n    };\n\n    if (variant && this.children) {\n      var transition = this.resolveVariant(variant).transition;\n\n      if (transition) {\n        when = transition.when || when;\n        delayChildren = transition.delayChildren || delayChildren;\n        staggerChildren = transition.staggerChildren || staggerChildren;\n        staggerDirection = transition.staggerDirection || staggerDirection;\n      }\n    }\n\n    if (when) {\n      var _a = when === \"beforeChildren\" ? [getAnimations, getChildrenAnimations] : [getChildrenAnimations, getAnimations],\n          first = _a[0],\n          last = _a[1];\n\n      return first().then(last);\n    } else {\n      return Promise.all([getAnimations(), getChildrenAnimations()]);\n    }\n  };\n\n  VisualElementAnimationControls.prototype.animateChildren = function (variantLabel, delayChildren, staggerChildren, staggerDirection, priority) {\n    if (delayChildren === void 0) {\n      delayChildren = 0;\n    }\n\n    if (staggerChildren === void 0) {\n      staggerChildren = 0;\n    }\n\n    if (staggerDirection === void 0) {\n      staggerDirection = 1;\n    }\n\n    if (priority === void 0) {\n      priority = 0;\n    }\n\n    if (!this.children) {\n      return Promise.resolve();\n    }\n\n    var animations = [];\n    var maxStaggerDuration = (this.children.size - 1) * staggerChildren;\n    var generateStaggerDuration = staggerDirection === 1 ? function (i) {\n      return i * staggerChildren;\n    } : function (i) {\n      return maxStaggerDuration - i * staggerChildren;\n    };\n    Array.from(this.children).forEach(function (childControls, i) {\n      var animation = childControls.animateVariant(variantLabel, {\n        priority: priority,\n        delay: delayChildren + generateStaggerDuration(i)\n      });\n      animations.push(animation);\n    });\n    return Promise.all(animations);\n  };\n\n  VisualElementAnimationControls.prototype.onStart = function () {\n    var onAnimationStart = this.props.onAnimationStart;\n    onAnimationStart && onAnimationStart();\n  };\n\n  VisualElementAnimationControls.prototype.onComplete = function () {\n    var onAnimationComplete = this.props.onAnimationComplete;\n    onAnimationComplete && onAnimationComplete();\n  };\n\n  VisualElementAnimationControls.prototype.checkOverrideIsAnimating = function (priority) {\n    var numOverrides = this.overrides.length;\n\n    for (var i = priority + 1; i < numOverrides; i++) {\n      var resolvedOverride = this.resolvedOverrides[i];\n\n      if (resolvedOverride) {\n        for (var key in resolvedOverride) {\n          this.isAnimating.add(key);\n        }\n      }\n    }\n  };\n\n  VisualElementAnimationControls.prototype.resetIsAnimating = function (priority) {\n    if (priority === void 0) {\n      priority = 0;\n    }\n\n    this.isAnimating.clear(); // If this isn't the highest priority gesture, block the animation\n    // of anything that's currently being animated\n\n    if (priority < this.getHighestPriority()) {\n      this.checkOverrideIsAnimating(priority);\n    }\n\n    if (this.children) {\n      this.children.forEach(function (child) {\n        return child.resetIsAnimating(priority);\n      });\n    }\n  };\n\n  VisualElementAnimationControls.prototype.stop = function () {\n    this.visualElement.forEachValue(function (value) {\n      return value.stop();\n    });\n  };\n  /**\n   * Add the controls of a child component.\n   * @param controls -\n   */\n\n\n  VisualElementAnimationControls.prototype.addChild = function (controls) {\n    if (!this.children) {\n      this.children = new Set();\n    }\n\n    this.children.add(controls); // We set child overrides when `setOverride` is called, but also have to do it here\n    // as the first time `setOverride` is called all the children might not have been added yet.\n\n    this.overrides.forEach(function (override, i) {\n      override && controls.setOverride(override, i);\n    });\n  };\n\n  VisualElementAnimationControls.prototype.removeChild = function (controls) {\n    if (!this.children) {\n      return;\n    }\n\n    this.children[\"delete\"](controls);\n  };\n\n  VisualElementAnimationControls.prototype.resetChildren = function () {\n    if (this.children) this.children.clear();\n  };\n\n  return VisualElementAnimationControls;\n}();\n\nfunction getOriginFromTransition(key, transition) {\n  if (!transition) return;\n  var valueTransition = transition[key] || transition[\"default\"] || transition;\n  return valueTransition.from;\n}\n\nfunction getOrigin(target, transition, visualElement) {\n  var _a, _b;\n\n  var origin = {};\n\n  for (var key in target) {\n    origin[key] = (_a = getOriginFromTransition(key, transition)) !== null && _a !== void 0 ? _a : (_b = visualElement.getValue(key)) === null || _b === void 0 ? void 0 : _b.get();\n  }\n\n  return origin;\n}\n/**\n * Creates an imperative set of controls to trigger animations.\n *\n * This allows a consolidated, uniform API for animations, to be triggered by other APIs like the `animate` prop, or the gesture handlers.\n *\n * @internal\n */\n\n\nfunction useVisualElementAnimation(visualElement, props, config) {\n  var subscribeToParentControls = checkShouldInheritVariant(props);\n  var variants = props.variants,\n      transition = props.transition;\n  var parentControls = useContext(MotionContext).controls;\n  var presenceContext = useContext(PresenceContext);\n  var controls = useConstant(function () {\n    return new VisualElementAnimationControls(visualElement, config);\n  }); // Reset and resubscribe children every render to ensure stagger order is correct\n\n  if (!presenceContext || presenceContext.isPresent) {\n    controls.resetChildren();\n    controls.setProps(props);\n    controls.setVariants(variants);\n    controls.setDefaultTransition(transition);\n  } // We have to subscribe to the parent controls within a useEffect rather than during render,\n  // as\n\n\n  useEffect(function () {\n    if (subscribeToParentControls && parentControls) {\n      parentControls.addChild(controls);\n    }\n  });\n  useEffect(function () {\n    return function () {\n      // Remove reference to onAnimationComplete from controls. All the MotionValues\n      // are unsubscribed from this component separately. We let animations run out\n      // as they might be animating other components.\n      var onAnimationComplete = props.onAnimationComplete,\n          unmountProps = __rest(props, [\"onAnimationComplete\"]);\n\n      controls.setProps(unmountProps);\n      parentControls && parentControls.removeChild(controls);\n    };\n  }, []);\n  return controls;\n}\n/**\n * @internal\n */\n\n\nvar MotionPluginContext = createContext({\n  transformPagePoint: function transformPagePoint(p) {\n    return p;\n  },\n  features: []\n});\n/**\n * @remarks For now I think this should remain a private API for our own use\n * until we can figure out a nicer way of allowing people to add these\n *\n * @internal\n */\n\nfunction MotionPlugins(_a) {\n  var children = _a.children,\n      props = __rest(_a, [\"children\"]);\n\n  var pluginContext = useContext(MotionPluginContext);\n  var value = useRef(__assign({}, pluginContext)).current; // Mutative to prevent triggering rerenders in all listening\n  // components every time this component renders\n\n  for (var key in props) {\n    value[key] = props[key];\n  }\n\n  return createElement(MotionPluginContext.Provider, {\n    value: value\n  }, children);\n}\n\nfunction createLock(name) {\n  var lock = null;\n  return function () {\n    var openLock = function openLock() {\n      lock = null;\n    };\n\n    if (lock === null) {\n      lock = name;\n      return openLock;\n    }\n\n    return false;\n  };\n}\n\nvar globalHorizontalLock = createLock(\"dragHorizontal\");\nvar globalVerticalLock = createLock(\"dragVertical\");\n\nfunction getGlobalLock(drag) {\n  var lock = false;\n\n  if (drag === \"y\") {\n    lock = globalVerticalLock();\n  } else if (drag === \"x\") {\n    lock = globalHorizontalLock();\n  } else {\n    var openHorizontal_1 = globalHorizontalLock();\n    var openVertical_1 = globalVerticalLock();\n\n    if (openHorizontal_1 && openVertical_1) {\n      lock = function lock() {\n        openHorizontal_1();\n        openVertical_1();\n      };\n    } else {\n      // Release the locks because we don't use them\n      if (openHorizontal_1) openHorizontal_1();\n      if (openVertical_1) openVertical_1();\n    }\n  }\n\n  return lock;\n}\n\nvar isViewportScrollBlocked = false;\nvar isBrowser = typeof window !== \"undefined\";\n\nif (isBrowser) {\n  document.addEventListener(\"touchmove\", function (event) {\n    if (isViewportScrollBlocked) {\n      event.preventDefault();\n    }\n  }, {\n    passive: false\n  });\n}\n\nvar blockViewportScroll = function blockViewportScroll() {\n  return isViewportScrollBlocked = true;\n};\n\nvar unblockViewportScroll = function unblockViewportScroll() {\n  return isViewportScrollBlocked = false;\n};\n\nfunction addDomEvent(target, eventName, handler, options) {\n  if (!handler) return;\n  target.addEventListener(eventName, handler, options);\n  return function () {\n    return target.removeEventListener(eventName, handler, options);\n  };\n}\n/**\n * Attaches an event listener directly to the provided DOM element.\n *\n * Bypassing React's event system can be desirable, for instance when attaching non-passive\n * event handlers.\n *\n * ```jsx\n * const ref = useRef(null)\n *\n * useDomEvent(ref, 'wheel', onWheel, { passive: false })\n *\n * return <div ref={ref} />\n * ```\n *\n * @param ref - React.RefObject that's been provided to the element you want to bind the listener to.\n * @param eventName - Name of the event you want listen for.\n * @param handler - Function to fire when receiving the event.\n * @param options - Options to pass to `Event.addEventListener`.\n *\n * @public\n */\n\n\nfunction useDomEvent(ref, eventName, handler, options) {\n  useEffect(function () {\n    var element = ref.current;\n\n    if (handler && element) {\n      return addDomEvent(element, eventName, handler, options);\n    }\n  }, [ref, eventName, handler, options]);\n}\n\nfunction isMouseEvent(event) {\n  // PointerEvent inherits from MouseEvent so we can't use a straight instanceof check.\n  if (typeof PointerEvent !== \"undefined\" && event instanceof PointerEvent) {\n    return !!(event.pointerType === \"mouse\");\n  }\n\n  return event instanceof MouseEvent;\n}\n\nfunction isTouchEvent(event) {\n  var hasTouches = !!event.touches;\n  return hasTouches;\n}\n/**\n * Filters out events not attached to the primary pointer (currently left mouse button)\n * @param eventHandler\n */\n\n\nfunction filterPrimaryPointer(eventHandler) {\n  if (!eventHandler) return undefined;\n  return function (event) {\n    var isMouseEvent = event instanceof MouseEvent;\n    var isPrimaryPointer = !isMouseEvent || isMouseEvent && event.button === 0;\n\n    if (isPrimaryPointer) {\n      eventHandler(event);\n    }\n  };\n}\n\nvar defaultPagePoint = {\n  pageX: 0,\n  pageY: 0\n};\n\nfunction pointFromTouch(e, pointType) {\n  if (pointType === void 0) {\n    pointType = \"page\";\n  }\n\n  var primaryTouch = e.touches[0] || e.changedTouches[0];\n  var point = primaryTouch || defaultPagePoint;\n  return {\n    x: point[pointType + \"X\"],\n    y: point[pointType + \"Y\"]\n  };\n}\n\nfunction pointFromMouse(point, pointType) {\n  if (pointType === void 0) {\n    pointType = \"page\";\n  }\n\n  return {\n    x: point[pointType + \"X\"],\n    y: point[pointType + \"Y\"]\n  };\n}\n\nfunction extractEventInfo(event, pointType) {\n  if (pointType === void 0) {\n    pointType = \"page\";\n  }\n\n  return {\n    point: isTouchEvent(event) ? pointFromTouch(event, pointType) : pointFromMouse(event, pointType)\n  };\n}\n\nfunction getViewportPointFromEvent(event) {\n  return extractEventInfo(event, \"client\");\n}\n\nvar wrapHandler = function wrapHandler(handler, shouldFilterPrimaryPointer) {\n  if (shouldFilterPrimaryPointer === void 0) {\n    shouldFilterPrimaryPointer = false;\n  }\n\n  if (!handler) return;\n\n  var listener = function listener(event) {\n    return handler(event, extractEventInfo(event));\n  };\n\n  return shouldFilterPrimaryPointer ? filterPrimaryPointer(listener) : listener;\n};\n\nvar isBrowser$1 = typeof window !== \"undefined\"; // We check for event support via functions in case they've been mocked by a testing suite.\n\nvar supportsPointerEvents = function supportsPointerEvents() {\n  return isBrowser$1 && window.onpointerdown === null;\n};\n\nvar supportsTouchEvents = function supportsTouchEvents() {\n  return isBrowser$1 && window.ontouchstart === null;\n};\n\nvar supportsMouseEvents = function supportsMouseEvents() {\n  return isBrowser$1 && window.onmousedown === null;\n};\n\nvar mouseEventNames = {\n  pointerdown: \"mousedown\",\n  pointermove: \"mousemove\",\n  pointerup: \"mouseup\",\n  pointercancel: \"mousecancel\",\n  pointerover: \"mouseover\",\n  pointerout: \"mouseout\",\n  pointerenter: \"mouseenter\",\n  pointerleave: \"mouseleave\"\n};\nvar touchEventNames = {\n  pointerdown: \"touchstart\",\n  pointermove: \"touchmove\",\n  pointerup: \"touchend\",\n  pointercancel: \"touchcancel\"\n};\n\nfunction getPointerEventName(name) {\n  if (supportsPointerEvents()) {\n    return name;\n  } else if (supportsTouchEvents()) {\n    return touchEventNames[name];\n  } else if (supportsMouseEvents()) {\n    return mouseEventNames[name];\n  }\n\n  return name;\n}\n\nfunction addPointerEvent(target, eventName, handler, options) {\n  return addDomEvent(target, getPointerEventName(eventName), wrapHandler(handler, eventName === \"pointerdown\"), options);\n}\n\nfunction usePointerEvent(ref, eventName, handler, options) {\n  return useDomEvent(ref, getPointerEventName(eventName), wrapHandler(handler, eventName === \"pointerdown\"), options);\n}\n/** @public */\n\n\nvar Point;\n\n(function (Point) {\n  /** @beta */\n  Point.subtract = function (a, b) {\n    return {\n      x: a.x - b.x,\n      y: a.y - b.y\n    };\n  };\n  /** @beta */\n\n\n  Point.relativeTo = function (idOrElem) {\n    var elem;\n\n    var getElem = function getElem() {\n      // Caching element here could be leaky because of React lifecycle\n      if (elem !== undefined) return elem;\n\n      if (typeof idOrElem === \"string\") {\n        elem = document.getElementById(idOrElem);\n      } else {\n        elem = idOrElem;\n      }\n\n      return elem;\n    };\n\n    return function (_a) {\n      var x = _a.x,\n          y = _a.y;\n      var localElem = getElem();\n      if (!localElem) return undefined;\n      var rect = localElem.getBoundingClientRect();\n      return {\n        x: x - rect.left - window.scrollX,\n        y: y - rect.top - window.scrollY\n      };\n    };\n  };\n})(Point || (Point = {}));\n/**\n * @internal\n */\n\n\nvar PanSession =\n/** @class */\nfunction () {\n  function PanSession(event, handlers, _a) {\n    var _this = this;\n\n    var transformPagePoint = (_a === void 0 ? {} : _a).transformPagePoint;\n    /**\n     * @internal\n     */\n\n    this.startEvent = null;\n    /**\n     * @internal\n     */\n\n    this.lastMoveEvent = null;\n    /**\n     * @internal\n     */\n\n    this.lastMoveEventInfo = null;\n    /**\n     * @internal\n     */\n\n    this.handlers = {};\n\n    this.updatePoint = function () {\n      if (!(_this.lastMoveEvent && _this.lastMoveEventInfo)) return;\n      var info = getPanInfo(_this.lastMoveEventInfo, _this.history);\n      var isPanStarted = _this.startEvent !== null; // Only start panning if the offset is larger than 3 pixels. If we make it\n      // any larger than this we'll want to reset the pointer history\n      // on the first update to avoid visual snapping to the cursoe.\n\n      var isDistancePastThreshold = distance(info.offset, {\n        x: 0,\n        y: 0\n      }) >= 3;\n      if (!isPanStarted && !isDistancePastThreshold) return;\n      var point = info.point;\n      var timestamp = getFrameData().timestamp;\n\n      _this.history.push(__assign(__assign({}, point), {\n        timestamp: timestamp\n      }));\n\n      var _a = _this.handlers,\n          onStart = _a.onStart,\n          onMove = _a.onMove;\n\n      if (!isPanStarted) {\n        onStart && onStart(_this.lastMoveEvent, info);\n        _this.startEvent = _this.lastMoveEvent;\n      }\n\n      onMove && onMove(_this.lastMoveEvent, info);\n    }; // If we have more than one touch, don't start detecting this gesture\n\n\n    if (isTouchEvent(event) && event.touches.length > 1) return;\n    this.handlers = handlers;\n    this.transformPagePoint = transformPagePoint;\n    var info = extractEventInfo(event);\n    var initialInfo = transformPoint(info, this.transformPagePoint);\n    var point = initialInfo.point;\n    var timestamp = getFrameData().timestamp;\n    this.history = [__assign(__assign({}, point), {\n      timestamp: timestamp\n    })];\n    var onSessionStart = handlers.onSessionStart;\n    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));\n    var removeOnPointerMove = addPointerEvent(window, \"pointermove\", function (event, info) {\n      return _this.handlePointerMove(event, info);\n    });\n    var removeOnPointerUp = addPointerEvent(window, \"pointerup\", function (event, info) {\n      return _this.handlePointerUp(event, info);\n    });\n\n    this.removeListeners = function () {\n      removeOnPointerMove && removeOnPointerMove();\n      removeOnPointerUp && removeOnPointerUp();\n    };\n  }\n\n  PanSession.prototype.handlePointerMove = function (event, info) {\n    this.lastMoveEvent = event;\n    this.lastMoveEventInfo = transformPoint(info, this.transformPagePoint); // Because Safari doesn't trigger mouseup events when it's above a `<select>`\n\n    if (isMouseEvent(event) && event.buttons === 0) {\n      this.handlePointerUp(event, info);\n      return;\n    } // Throttle mouse move event to once per frame\n\n\n    sync.update(this.updatePoint, true);\n  };\n\n  PanSession.prototype.handlePointerUp = function (event, info) {\n    this.end();\n    var onEnd = this.handlers.onEnd;\n    if (!onEnd) return;\n    var panInfo = getPanInfo(transformPoint(info, this.transformPagePoint), this.history);\n    onEnd && onEnd(event, panInfo);\n  };\n\n  PanSession.prototype.updateHandlers = function (handlers) {\n    this.handlers = handlers;\n  };\n\n  PanSession.prototype.end = function () {\n    this.removeListeners && this.removeListeners();\n    cancelSync.update(this.updatePoint);\n    unblockViewportScroll();\n  };\n\n  return PanSession;\n}();\n\nfunction transformPoint(info, transformPagePoint) {\n  return transformPagePoint ? {\n    point: transformPagePoint(info.point)\n  } : info;\n}\n\nfunction getPanInfo(_a, history) {\n  var point = _a.point;\n  return {\n    point: point,\n    delta: Point.subtract(point, lastDevicePoint(history)),\n    offset: Point.subtract(point, startDevicePoint(history)),\n    velocity: getVelocity$1(history, 0.1)\n  };\n}\n\nfunction startDevicePoint(history) {\n  return history[0];\n}\n\nfunction lastDevicePoint(history) {\n  return history[history.length - 1];\n}\n\nfunction getVelocity$1(history, timeDelta) {\n  if (history.length < 2) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n\n  var i = history.length - 1;\n  var timestampedPoint = null;\n  var lastPoint = lastDevicePoint(history);\n\n  while (i >= 0) {\n    timestampedPoint = history[i];\n\n    if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {\n      break;\n    }\n\n    i--;\n  }\n\n  if (!timestampedPoint) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n\n  var time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1000;\n\n  if (time === 0) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n\n  var currentVelocity = {\n    x: (lastPoint.x - timestampedPoint.x) / time,\n    y: (lastPoint.y - timestampedPoint.y) / time\n  };\n\n  if (currentVelocity.x === Infinity) {\n    currentVelocity.x = 0;\n  }\n\n  if (currentVelocity.y === Infinity) {\n    currentVelocity.y = 0;\n  }\n\n  return currentVelocity;\n}\n/**\n * Apply constraints to a point. These constraints are both physical along an\n * axis, and an elastic factor that determines how much to constrain the point\n * by if it does lie outside the defined parameters.\n */\n\n\nfunction applyConstraints(point, _a, elastic) {\n  var min = _a.min,\n      max = _a.max;\n\n  if (min !== undefined && point < min) {\n    // If we have a min point defined, and this is outside of that, constrain\n    point = elastic ? mix(min, point, elastic) : Math.max(point, min);\n  } else if (max !== undefined && point > max) {\n    // If we have a max point defined, and this is outside of that, constrain\n    point = elastic ? mix(max, point, elastic) : Math.min(point, max);\n  }\n\n  return point;\n}\n/**\n * Calculates a min projection point based on a pointer, pointer progress\n * within the drag target, and constraints.\n *\n * For instance if an element was 100px width, we were dragging from 0.25\n * along this axis, the pointer is at 200px, and there were no constraints,\n * we would calculate a min projection point of 175px.\n */\n\n\nfunction calcConstrainedMinPoint(point, length, progress, constraints, elastic) {\n  // Calculate a min point for this axis and apply it to the current pointer\n  var min = point - length * progress;\n  return constraints ? applyConstraints(min, constraints, elastic) : min;\n}\n/**\n * Calculate constraints in terms of the viewport when\n * defined relatively to the measured axis.\n */\n\n\nfunction calcRelativeAxisConstraints(axis, min, max) {\n  var constraints = {};\n  var length = axis.max - axis.min;\n\n  if (min !== undefined) {\n    constraints.min = axis.min + min;\n  }\n\n  if (max !== undefined) {\n    constraints.max = Math.max(axis.min + max - length, axis.min + max);\n  }\n\n  return constraints;\n}\n/**\n * Calculate constraints in terms of the viewport when\n * defined relatively to the measured bounding box.\n */\n\n\nfunction calcRelativeConstraints(layoutBox, _a) {\n  var top = _a.top,\n      left = _a.left,\n      bottom = _a.bottom,\n      right = _a.right;\n  return {\n    x: calcRelativeAxisConstraints(layoutBox.x, left, right),\n    y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)\n  };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative axis\n */\n\n\nfunction calcViewportAxisConstraints(layoutAxis, constraintsAxis) {\n  var _a;\n\n  var min = constraintsAxis.min - layoutAxis.min;\n  var max = constraintsAxis.max - layoutAxis.max; // If the constraints axis is actually smaller than the layout axis then we can\n  // flip the constraints\n\n  if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {\n    _a = [max, min], min = _a[0], max = _a[1];\n  }\n\n  return {\n    min: layoutAxis.min + min,\n    max: layoutAxis.min + max\n  };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative box\n */\n\n\nfunction calcViewportConstraints(layoutBox, constraintsBox) {\n  return {\n    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),\n    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)\n  };\n}\n/**\n * Calculate the an axis position based on two axes and a progress value.\n */\n\n\nfunction calcPositionFromProgress(axis, constraints, progress) {\n  var axisLength = axis.max - axis.min;\n  var min = mix(constraints.min, constraints.max - axisLength, progress);\n  return {\n    min: min,\n    max: min + axisLength\n  };\n}\n\nvar elementDragControls = new WeakMap();\n/**\n *\n */\n\nvar lastPointerEvent;\n\nvar VisualElementDragControls =\n/** @class */\nfunction () {\n  function VisualElementDragControls(_a) {\n    var visualElement = _a.visualElement;\n    /**\n     * Track whether we're currently dragging.\n     *\n     * @internal\n     */\n\n    this.isDragging = false;\n    /**\n     * The current direction of drag, or `null` if both.\n     *\n     * @internal\n     */\n\n    this.currentDirection = null;\n    /**\n     * The permitted boundaries of travel, in pixels.\n     *\n     * @internal\n     */\n\n    this.constraints = false;\n    /**\n     * A reference to the host component's latest props.\n     *\n     * @internal\n     */\n\n    this.props = {};\n    /**\n     * Track the initial position of the cursor relative to the dragging element\n     * when dragging starts as a value of 0-1 on each axis. We then use this to calculate\n     * an ideal bounding box for the VisualElement renderer to project into every frame.\n     *\n     * @internal\n     */\n\n    this.cursorProgress = {\n      x: 0.5,\n      y: 0.5\n    }; // This is a reference to the global drag gesture lock, ensuring only one component\n    // can \"capture\" the drag of one or both axes.\n    // TODO: Look into moving this into pansession?\n\n    this.openGlobalLock = null;\n    /**\n     * @internal\n     */\n\n    this.panSession = null;\n    this.visualElement = visualElement;\n    this.visualElement.enableLayoutProjection();\n    elementDragControls.set(visualElement, this);\n  }\n  /**\n   * Instantiate a PanSession for the drag gesture\n   *\n   * @public\n   */\n\n\n  VisualElementDragControls.prototype.start = function (originEvent, _a) {\n    var _this = this;\n\n    var _b = _a === void 0 ? {} : _a,\n        _c = _b.snapToCursor,\n        snapToCursor = _c === void 0 ? false : _c,\n        cursorProgress = _b.cursorProgress;\n    /**\n     * If this drag session has been manually triggered by the user, it might be from an event\n     * outside the draggable element. If snapToCursor is set to true, we need to measure the position\n     * of the element and snap it to the cursor.\n     */\n\n\n    snapToCursor && this.snapToCursor(originEvent);\n\n    var onSessionStart = function onSessionStart() {\n      // Initiate viewport scroll blocking on touch start. This is a very aggressive approach\n      // which has come out of the difficulty in us being able to do this once a scroll gesture\n      // has initiated in mobile browsers. This means if there's a horizontally-scrolling carousel\n      // on a page we can't let a user scroll the page itself from it. Ideally what we'd do is\n      // trigger this once we've got a scroll direction determined. This approach sort-of worked\n      // but if the component was dragged too far in a single frame page scrolling would initiate.\n      blockViewportScroll(); // Stop any animations on both axis values immediately. This allows the user to throw and catch\n      // the component.\n\n      _this.stopMotion();\n    };\n\n    var onStart = function onStart(event, info) {\n      var _a, _b; // Attempt to grab the global drag gesture lock - maybe make this part of PanSession\n\n\n      var _c = _this.props,\n          drag = _c.drag,\n          dragPropagation = _c.dragPropagation;\n\n      if (drag && !dragPropagation) {\n        if (_this.openGlobalLock) _this.openGlobalLock();\n        _this.openGlobalLock = getGlobalLock(drag); // If we don 't have the lock, don't start dragging\n\n        if (!_this.openGlobalLock) return;\n      }\n      /**\n       * Record the progress of the mouse within the draggable element on each axis.\n       * onPan, we're going to use this to calculate a new bounding box for the element to\n       * project into. This will ensure that even if the DOM element moves via a relayout, it'll\n       * stick to the correct place under the pointer.\n       */\n\n\n      _this.prepareBoundingBox();\n\n      _this.visualElement.lockTargetBox();\n      /**\n       * Resolve the drag constraints. These are either set as top/right/bottom/left constraints\n       * relative to the element's layout, or a ref to another element. Both need converting to\n       * viewport coordinates.\n       */\n\n\n      _this.resolveDragConstraints();\n      /**\n       * When dragging starts, we want to find where the cursor is relative to the bounding box\n       * of the element. Every frame, we calculate a new bounding box using this relative position\n       * and let the visualElement renderer figure out how to reproject the element into this bounding\n       * box.\n       *\n       * By doing it this way, rather than applying an x/y transform directly to the element,\n       * we can ensure the component always visually sticks to the cursor as we'd expect, even\n       * if the DOM element itself changes layout as a result of React updates the user might\n       * make based on the drag position.\n       */\n\n\n      var point = getViewportPointFromEvent(event).point;\n      eachAxis(function (axis) {\n        var _a = _this.visualElement.targetBox[axis],\n            min = _a.min,\n            max = _a.max;\n        _this.cursorProgress[axis] = cursorProgress ? cursorProgress[axis] : progress(min, max, point[axis]);\n      }); // Set current drag status\n\n      _this.isDragging = true;\n      _this.currentDirection = null; // Fire onDragStart event\n\n      (_b = (_a = _this.props).onDragStart) === null || _b === void 0 ? void 0 : _b.call(_a, event, info);\n    };\n\n    var onMove = function onMove(event, info) {\n      var _a, _b, _c, _d;\n\n      var _e = _this.props,\n          dragPropagation = _e.dragPropagation,\n          dragDirectionLock = _e.dragDirectionLock; // If we didn't successfully receive the gesture lock, early return.\n\n      if (!dragPropagation && !_this.openGlobalLock) return;\n      var offset = info.offset; // Attempt to detect drag direction if directionLock is true\n\n      if (dragDirectionLock && _this.currentDirection === null) {\n        _this.currentDirection = getCurrentDirection(offset); // If we've successfully set a direction, notify listener\n\n        if (_this.currentDirection !== null) {\n          (_b = (_a = _this.props).onDirectionLock) === null || _b === void 0 ? void 0 : _b.call(_a, _this.currentDirection);\n        }\n\n        return;\n      } // Update each point with the latest position\n\n\n      _this.updateAxis(\"x\", event);\n\n      _this.updateAxis(\"y\", event); // Fire onDrag event\n\n\n      (_d = (_c = _this.props).onDrag) === null || _d === void 0 ? void 0 : _d.call(_c, event, info); // Update the last pointer event\n\n      lastPointerEvent = event;\n    };\n\n    var onEnd = function onEnd(event, info) {\n      return _this.stop(event, info);\n    };\n\n    var transformPagePoint = this.props.transformPagePoint;\n    this.panSession = new PanSession(originEvent, {\n      onSessionStart: onSessionStart,\n      onStart: onStart,\n      onMove: onMove,\n      onEnd: onEnd\n    }, {\n      transformPagePoint: transformPagePoint\n    });\n  };\n  /**\n   * Ensure the component's layout and target bounding boxes are up-to-date.\n   */\n\n\n  VisualElementDragControls.prototype.prepareBoundingBox = function () {\n    var element = this.visualElement.getInstance();\n    var transform = element.style.transform;\n    this.visualElement.resetTransform();\n    this.visualElement.measureLayout();\n    element.style.transform = transform;\n    this.visualElement.refreshTargetBox();\n  };\n\n  VisualElementDragControls.prototype.resolveDragConstraints = function () {\n    var dragConstraints = this.props.dragConstraints;\n\n    if (dragConstraints) {\n      this.constraints = isRefObject(dragConstraints) ? this.resolveRefConstraints(this.visualElement.box, dragConstraints) : calcRelativeConstraints(this.visualElement.box, dragConstraints);\n    } else {\n      this.constraints = false;\n    }\n  };\n\n  VisualElementDragControls.prototype.resolveRefConstraints = function (layoutBox, constraints) {\n    var _a = this.props,\n        onMeasureDragConstraints = _a.onMeasureDragConstraints,\n        transformPagePoint = _a.transformPagePoint;\n    var constraintsElement = constraints.current;\n    invariant(constraintsElement !== null, \"If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.\");\n    this.constraintsBox = getBoundingBox(constraintsElement, transformPagePoint);\n    var measuredConstraints = calcViewportConstraints(layoutBox, this.constraintsBox);\n    /**\n     * If there's an onMeasureDragConstraints listener we call it and\n     * if different constraints are returned, set constraints to that\n     */\n\n    if (onMeasureDragConstraints) {\n      var userConstraints = onMeasureDragConstraints(convertAxisBoxToBoundingBox(measuredConstraints));\n\n      if (userConstraints) {\n        measuredConstraints = convertBoundingBoxToAxisBox(userConstraints);\n      }\n    }\n\n    return measuredConstraints;\n  };\n\n  VisualElementDragControls.prototype.cancelDrag = function () {\n    unblockViewportScroll();\n    this.isDragging = false;\n    this.panSession && this.panSession.end();\n    this.panSession = null;\n\n    if (!this.props.dragPropagation && this.openGlobalLock) {\n      this.openGlobalLock();\n      this.openGlobalLock = null;\n    }\n  };\n\n  VisualElementDragControls.prototype.stop = function (event, info) {\n    var _a;\n\n    this.visualElement.unlockTargetBox();\n    (_a = this.panSession) === null || _a === void 0 ? void 0 : _a.end();\n    this.panSession = null;\n    var isDragging = this.isDragging;\n    this.cancelDrag();\n    if (!isDragging) return;\n    var _b = this.props,\n        dragMomentum = _b.dragMomentum,\n        dragElastic = _b.dragElastic,\n        onDragEnd = _b.onDragEnd;\n\n    if (dragMomentum || dragElastic) {\n      var velocity = info.velocity;\n      this.animateDragEnd(velocity);\n    }\n\n    onDragEnd === null || onDragEnd === void 0 ? void 0 : onDragEnd(event, info);\n  };\n\n  VisualElementDragControls.prototype.snapToCursor = function (event) {\n    this.prepareBoundingBox();\n    this.cursorProgress.x = 0.5;\n    this.cursorProgress.y = 0.5;\n    this.updateAxis(\"x\", event);\n    this.updateAxis(\"y\", event);\n  };\n  /**\n   * Update the specified axis with the latest pointer information.\n   */\n\n\n  VisualElementDragControls.prototype.updateAxis = function (axis, event) {\n    var _a;\n\n    var _b = this.props,\n        drag = _b.drag,\n        dragElastic = _b.dragElastic; // If we're not dragging this axis, do an early return.\n\n    if (!shouldDrag(axis, drag, this.currentDirection)) return; // Get the actual layout bounding box of the element\n\n    var axisLayout = this.visualElement.box[axis]; // Calculate its current length. In the future we might want to lerp this to animate\n    // between lengths if the layout changes as we change the DOM\n\n    var axisLength = axisLayout.max - axisLayout.min; // Get the initial progress that the pointer sat on this axis on gesture start.\n\n    var axisProgress = this.cursorProgress[axis];\n    var point = getViewportPointFromEvent(event).point; // Calculate a new min point based on the latest pointer position, constraints and elastic\n\n    var min = calcConstrainedMinPoint(point[axis], axisLength, axisProgress, (_a = this.constraints) === null || _a === void 0 ? void 0 : _a[axis], dragElastic); // Update the axis viewport target with this new min and the length\n\n    this.visualElement.setAxisTarget(axis, min, min + axisLength);\n  };\n\n  VisualElementDragControls.prototype.updateProps = function (_a) {\n    var _b = _a.drag,\n        drag = _b === void 0 ? false : _b,\n        _c = _a.dragDirectionLock,\n        dragDirectionLock = _c === void 0 ? false : _c,\n        _d = _a.dragPropagation,\n        dragPropagation = _d === void 0 ? false : _d,\n        _e = _a.dragConstraints,\n        dragConstraints = _e === void 0 ? false : _e,\n        _f = _a.dragElastic,\n        dragElastic = _f === void 0 ? 0.35 : _f,\n        _g = _a.dragMomentum,\n        dragMomentum = _g === void 0 ? true : _g,\n        remainingProps = __rest(_a, [\"drag\", \"dragDirectionLock\", \"dragPropagation\", \"dragConstraints\", \"dragElastic\", \"dragMomentum\"]);\n\n    this.props = __assign({\n      drag: drag,\n      dragDirectionLock: dragDirectionLock,\n      dragPropagation: dragPropagation,\n      dragConstraints: dragConstraints,\n      dragElastic: dragElastic,\n      dragMomentum: dragMomentum\n    }, remainingProps);\n  };\n\n  VisualElementDragControls.prototype.animateDragEnd = function (velocity) {\n    var _this = this;\n\n    var _a = this.props,\n        drag = _a.drag,\n        dragMomentum = _a.dragMomentum,\n        dragElastic = _a.dragElastic,\n        dragTransition = _a.dragTransition;\n    var momentumAnimations = eachAxis(function (axis) {\n      if (!shouldDrag(axis, drag, _this.currentDirection)) {\n        return;\n      }\n\n      var transition = _this.constraints ? _this.constraints[axis] : {};\n      /**\n       * Overdamp the boundary spring if `dragElastic` is disabled. There's still a frame\n       * of spring animations so we should look into adding a disable spring option to `inertia`.\n       * We could do something here where we affect the `bounceStiffness` and `bounceDamping`\n       * using the value of `dragElastic`.\n       */\n\n      var bounceStiffness = dragElastic ? 200 : 1000000;\n      var bounceDamping = dragElastic ? 40 : 10000000;\n\n      var inertia = __assign(__assign({\n        type: \"inertia\",\n        velocity: dragMomentum ? velocity[axis] : 0,\n        bounceStiffness: bounceStiffness,\n        bounceDamping: bounceDamping,\n        timeConstant: 750,\n        restDelta: 1,\n        restSpeed: 10\n      }, dragTransition), transition); // If we're not animating on an externally-provided `MotionValue` we can use the\n      // component's animation controls which will handle interactions with whileHover (etc),\n      // otherwise we just have to animate the `MotionValue` itself.\n\n\n      return _this.visualElement.startLayoutAxisAnimation(axis, inertia);\n    }); // Run all animations and then resolve the new drag constraints.\n\n    return Promise.all(momentumAnimations).then(function () {\n      var _a, _b;\n\n      (_b = (_a = _this.props).onDragTransitionEnd) === null || _b === void 0 ? void 0 : _b.call(_a);\n    });\n  };\n\n  VisualElementDragControls.prototype.stopMotion = function () {\n    this.visualElement.stopLayoutAnimation();\n  };\n\n  VisualElementDragControls.prototype.scalePoint = function () {\n    var _this = this;\n\n    var _a = this.props,\n        drag = _a.drag,\n        dragConstraints = _a.dragConstraints;\n    if (!isRefObject(dragConstraints) || !this.constraintsBox) return; // Stop any current animations as there can be some visual glitching if we resize mid animation\n\n    this.stopMotion(); // Record the relative progress of the targetBox relative to the constraintsBox\n\n    var boxProgress = {\n      x: 0,\n      y: 0\n    };\n    eachAxis(function (axis) {\n      boxProgress[axis] = calcOrigin(_this.visualElement.targetBox[axis], _this.constraintsBox[axis]);\n    });\n    /**\n     * For each axis, calculate the current progress of the layout axis within the constraints.\n     * Then, using the latest layout and constraints measurements, reposition the new layout axis\n     * proportionally within the constraints.\n     */\n\n    this.prepareBoundingBox();\n    this.resolveDragConstraints();\n    eachAxis(function (axis) {\n      if (!shouldDrag(axis, drag, null)) return; // Calculate the position of the targetBox relative to the constraintsBox using the\n      // previously calculated progress\n\n      var _a = calcPositionFromProgress(_this.visualElement.targetBox[axis], _this.constraintsBox[axis], boxProgress[axis]),\n          min = _a.min,\n          max = _a.max;\n\n      _this.visualElement.setAxisTarget(axis, min, max);\n    });\n  };\n\n  VisualElementDragControls.prototype.mount = function (visualElement) {\n    var _this = this;\n\n    var element = visualElement.getInstance();\n    /**\n     * Attach a pointerdown event listener on this DOM element to initiate drag tracking.\n     */\n\n    var stopPointerListener = addPointerEvent(element, \"pointerdown\", function (event) {\n      var _a = _this.props,\n          drag = _a.drag,\n          _b = _a.dragListener,\n          dragListener = _b === void 0 ? true : _b;\n      drag && dragListener && _this.start(event);\n    });\n    /**\n     * Attach a window resize listener to scale the draggable target within its defined\n     * constraints as the window resizes.\n     */\n\n    var stopResizeListener = addDomEvent(window, \"resize\", function () {\n      _this.scalePoint();\n    });\n    /**\n     * Ensure drag constraints are resolved correctly relative to the dragging element\n     * whenever its layout changes.\n     */\n\n    var stopLayoutUpdateListener = visualElement.onLayoutUpdate(function () {\n      if (_this.isDragging) _this.resolveDragConstraints();\n    });\n    /**\n     * If the previous component with this same layoutId was dragging at the time\n     * it was unmounted, we want to continue the same gesture on this component.\n     */\n\n    var prevSnapshot = visualElement.prevSnapshot;\n    (prevSnapshot === null || prevSnapshot === void 0 ? void 0 : prevSnapshot.isDragging) && this.start(lastPointerEvent, {\n      cursorProgress: prevSnapshot.cursorProgress\n    });\n    /**\n     * Return a function that will teardown the drag gesture\n     */\n\n    return function () {\n      stopPointerListener === null || stopPointerListener === void 0 ? void 0 : stopPointerListener();\n      stopResizeListener === null || stopResizeListener === void 0 ? void 0 : stopResizeListener();\n      stopLayoutUpdateListener === null || stopLayoutUpdateListener === void 0 ? void 0 : stopLayoutUpdateListener();\n\n      _this.cancelDrag();\n    };\n  };\n\n  return VisualElementDragControls;\n}();\n\nfunction shouldDrag(direction, drag, currentDirection) {\n  return (drag === true || drag === direction) && (currentDirection === null || currentDirection === direction);\n}\n/**\n * Based on an x/y offset determine the current drag direction. If both axis' offsets are lower\n * than the provided threshold, return `null`.\n *\n * @param offset - The x/y offset from origin.\n * @param lockThreshold - (Optional) - the minimum absolute offset before we can determine a drag direction.\n */\n\n\nfunction getCurrentDirection(offset, lockThreshold) {\n  if (lockThreshold === void 0) {\n    lockThreshold = 10;\n  }\n\n  var direction = null;\n\n  if (Math.abs(offset.y) > lockThreshold) {\n    direction = \"y\";\n  } else if (Math.abs(offset.x) > lockThreshold) {\n    direction = \"x\";\n  }\n\n  return direction;\n}\n/**\n * A hook that allows an element to be dragged.\n *\n * @internal\n */\n\n\nfunction useDrag(props, visualElement) {\n  var groupDragControls = props.dragControls;\n  var transformPagePoint = useContext(MotionPluginContext).transformPagePoint;\n  var dragControls = useConstant(function () {\n    return new VisualElementDragControls({\n      visualElement: visualElement\n    });\n  });\n  dragControls.updateProps(__assign(__assign({}, props), {\n    transformPagePoint: transformPagePoint\n  })); // If we've been provided a DragControls for manual control over the drag gesture,\n  // subscribe this component to it on mount.\n\n  useEffect(function () {\n    return groupDragControls && groupDragControls.subscribe(dragControls);\n  }, [dragControls]); // Mount the drag controls with the visualElement\n\n  useEffect(function () {\n    return dragControls.mount(visualElement);\n  }, []);\n}\n\nvar makeRenderlessComponent = function makeRenderlessComponent(hook) {\n  return function (props) {\n    hook(props);\n    return null;\n  };\n};\n\nvar Drag = {\n  key: \"drag\",\n  shouldRender: function shouldRender(props) {\n    return !!props.drag;\n  },\n  Component: makeRenderlessComponent(function (_a) {\n    var visualElement = _a.visualElement,\n        props = __rest(_a, [\"visualElement\"]);\n\n    return useDrag(props, visualElement);\n  })\n};\n\nfunction useUnmountEffect(callback) {\n  return useEffect(function () {\n    return function () {\n      return callback();\n    };\n  }, []);\n}\n/**\n *\n * @param handlers -\n * @param ref -\n *\n * @internalremarks\n * Currently this sets new pan gesture functions every render. The memo route has been explored\n * in the past but ultimately we're still creating new functions every render. An optimisation\n * to explore is creating the pan gestures and loading them into a `ref`.\n *\n * @internal\n */\n\n\nfunction usePanGesture(_a, ref) {\n  var onPan = _a.onPan,\n      onPanStart = _a.onPanStart,\n      onPanEnd = _a.onPanEnd,\n      onPanSessionStart = _a.onPanSessionStart;\n  var hasPanEvents = onPan || onPanStart || onPanEnd || onPanSessionStart;\n  var panSession = useRef(null);\n  var transformPagePoint = useContext(MotionPluginContext).transformPagePoint;\n  var handlers = {\n    onSessionStart: onPanSessionStart,\n    onStart: onPanStart,\n    onMove: onPan,\n    onEnd: function onEnd(event, info) {\n      panSession.current = null;\n      onPanEnd && onPanEnd(event, info);\n    }\n  };\n  useEffect(function () {\n    if (panSession.current !== null) {\n      panSession.current.updateHandlers(handlers);\n    }\n  });\n\n  function onPointerDown(event) {\n    panSession.current = new PanSession(event, handlers, {\n      transformPagePoint: transformPagePoint\n    });\n  }\n\n  usePointerEvent(ref, \"pointerdown\", hasPanEvents && onPointerDown);\n  useUnmountEffect(function () {\n    return panSession.current && panSession.current.end();\n  });\n}\n/**\n * Recursively traverse up the tree to check whether the provided child node\n * is the parent or a descendant of it.\n *\n * @param parent - Element to find\n * @param child - Element to test against parent\n */\n\n\nvar isNodeOrChild = function isNodeOrChild(parent, child) {\n  if (!child) {\n    return false;\n  } else if (parent === child) {\n    return true;\n  } else {\n    return isNodeOrChild(parent, child.parentElement);\n  }\n};\n\nvar order$1 = [\"whileHover\", \"whileTap\", \"whileDrag\"];\n\nvar getGesturePriority = function getGesturePriority(gesture) {\n  return order$1.indexOf(gesture) + 1;\n};\n\nvar tapGesturePriority = getGesturePriority(\"whileTap\");\n/**\n * @param handlers -\n * @internal\n */\n\nfunction useTapGesture(_a, ref) {\n  var onTap = _a.onTap,\n      onTapStart = _a.onTapStart,\n      onTapCancel = _a.onTapCancel,\n      whileTap = _a.whileTap,\n      controls = _a.controls;\n  var hasTapListeners = onTap || onTapStart || onTapCancel || whileTap;\n  var isTapping = useRef(false);\n  var cancelPointerEventListener = useRef(null);\n\n  function removePointerUp() {\n    cancelPointerEventListener.current && cancelPointerEventListener.current();\n    cancelPointerEventListener.current = null;\n  }\n\n  if (whileTap && controls) {\n    controls.setOverride(whileTap, tapGesturePriority);\n  } // We load this event handler into a ref so we can later refer to\n  // onPointerUp.current which will always have reference to the latest props\n\n\n  var onPointerUp = useRef(null);\n\n  onPointerUp.current = function (event, info) {\n    var element = ref.current;\n    removePointerUp();\n    if (!isTapping.current || !element) return;\n    isTapping.current = false;\n\n    if (controls && whileTap) {\n      controls.clearOverride(tapGesturePriority);\n    } // Check the gesture lock - if we get it, it means no drag gesture is active\n    // and we can safely fire the tap gesture.\n\n\n    var openGestureLock = getGlobalLock(true);\n    if (!openGestureLock) return;\n    openGestureLock();\n\n    if (!isNodeOrChild(element, event.target)) {\n      onTapCancel && onTapCancel(event, info);\n    } else {\n      onTap && onTap(event, info);\n    }\n  };\n\n  function onPointerDown(event, info) {\n    removePointerUp();\n    cancelPointerEventListener.current = addPointerEvent(window, \"pointerup\", function (event, info) {\n      return onPointerUp.current(event, info);\n    });\n    var element = ref.current;\n    if (!element || isTapping.current) return;\n    isTapping.current = true;\n    onTapStart && onTapStart(event, info);\n\n    if (controls && whileTap) {\n      controls.startOverride(tapGesturePriority);\n    }\n  }\n\n  usePointerEvent(ref, \"pointerdown\", hasTapListeners ? onPointerDown : undefined);\n  useUnmountEffect(removePointerUp);\n}\n\nvar hoverPriority = getGesturePriority(\"whileHover\");\n\nvar filterTouch = function filterTouch(listener) {\n  return function (event, info) {\n    if (isMouseEvent(event)) listener(event, info);\n  };\n};\n/**\n *\n * @param props\n * @param ref\n * @internal\n */\n\n\nfunction useHoverGesture(_a, ref) {\n  var whileHover = _a.whileHover,\n      onHoverStart = _a.onHoverStart,\n      onHoverEnd = _a.onHoverEnd,\n      controls = _a.controls;\n\n  if (whileHover && controls) {\n    controls.setOverride(whileHover, hoverPriority);\n  }\n\n  usePointerEvent(ref, \"pointerenter\", filterTouch(function (event, info) {\n    if (onHoverStart) onHoverStart(event, info);\n\n    if (whileHover && controls) {\n      controls.startOverride(hoverPriority);\n    }\n  }));\n  usePointerEvent(ref, \"pointerleave\", filterTouch(function (event, info) {\n    if (onHoverEnd) onHoverEnd(event, info);\n\n    if (whileHover && controls) {\n      controls.clearOverride(hoverPriority);\n    }\n  }));\n}\n/**\n * Add pan and tap gesture recognition to an element.\n *\n * @param props - Gesture event handlers\n * @param ref - React `ref` containing a DOM `Element`\n * @public\n */\n\n\nfunction useGestures(props, ref) {\n  usePanGesture(props, ref);\n  useTapGesture(props, ref);\n  useHoverGesture(props, ref);\n}\n\nvar gestureProps = [\"onPan\", \"onPanStart\", \"onPanEnd\", \"onPanSessionStart\", \"onTap\", \"onTapStart\", \"onTapCancel\", \"whileTap\", \"whileHover\", \"onHoverStart\", \"onHoverEnd\"];\nvar Gestures = {\n  key: \"gestures\",\n  shouldRender: function shouldRender(props) {\n    return gestureProps.some(function (key) {\n      return props.hasOwnProperty(key);\n    });\n  },\n  Component: makeRenderlessComponent(function (_a) {\n    var visualElement = _a.visualElement,\n        props = __rest(_a, [\"visualElement\"]);\n\n    useGestures(props, visualElement);\n  })\n};\nvar Exit = {\n  key: \"exit\",\n  shouldRender: function shouldRender(props) {\n    return !!props.exit && !checkShouldInheritVariant(props);\n  },\n  Component: makeRenderlessComponent(function (props) {\n    var animate = props.animate,\n        controls = props.controls,\n        exit = props.exit;\n\n    var _a = usePresence(),\n        isPresent = _a[0],\n        onExitComplete = _a[1];\n\n    var presenceContext = useContext(PresenceContext);\n    var isPlayingExitAnimation = useRef(false);\n    var custom = (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.custom) !== undefined ? presenceContext.custom : props.custom;\n    useEffect(function () {\n      if (!isPresent) {\n        if (!isPlayingExitAnimation.current && exit) {\n          controls.setProps(__assign(__assign({}, props), {\n            custom: custom\n          }));\n          controls.start(exit).then(onExitComplete);\n        }\n\n        isPlayingExitAnimation.current = true;\n      } else if (isPlayingExitAnimation.current && animate && typeof animate !== \"boolean\" && !(animate instanceof AnimationControls)) {\n        controls.start(animate);\n      }\n\n      if (isPresent) {\n        isPlayingExitAnimation.current = false;\n      }\n    }, [animate, controls, custom, exit, isPresent, onExitComplete, props]);\n  })\n};\nvar AnimatePropType;\n\n(function (AnimatePropType) {\n  AnimatePropType[\"Target\"] = \"Target\";\n  AnimatePropType[\"VariantLabel\"] = \"VariantLabel\";\n  AnimatePropType[\"AnimationSubscription\"] = \"AnimationSubscription\";\n})(AnimatePropType || (AnimatePropType = {}));\n\nfunction shallowCompare(next, prev) {\n  if (prev === null) return false;\n  var prevLength = prev.length;\n  if (prevLength !== next.length) return false;\n\n  for (var i = 0; i < prevLength; i++) {\n    if (prev[i] !== next[i]) return false;\n  }\n\n  return true;\n}\n\nvar hasUpdated = function hasUpdated(prev, next) {\n  return next !== undefined && (Array.isArray(prev) && Array.isArray(next) ? !shallowCompare(next, prev) : prev !== next);\n};\n\nfunction targetWithoutTransition(_a, mergeTransitionEnd) {\n  if (mergeTransitionEnd === void 0) {\n    mergeTransitionEnd = false;\n  }\n\n  var transition = _a.transition,\n      transitionEnd = _a.transitionEnd,\n      target = __rest(_a, [\"transition\", \"transitionEnd\"]);\n\n  return mergeTransitionEnd ? __assign(__assign({}, target), transitionEnd) : target;\n}\n/**\n * Handle the `animate` prop when its an object of values, ie:\n *\n * ```jsx\n * <motion.div animate={{ opacity: 1 }} />\n * ```\n *\n * @internalremarks\n * It might be worth consolidating this with `use-variants`\n *\n * ```jsx\n * <motion.div animate=\"visible\" />\n * ```\n *\n * @param target\n * @param controls\n * @param values\n * @param transition\n *\n * @internal\n */\n\n\nfunction useAnimateProp(targetAndTransition, controls, visualElement, defaultTransition) {\n  var isInitialRender = useRef(true);\n  var prevValues = useRef(null);\n\n  if (!prevValues.current) {\n    prevValues.current = targetWithoutTransition(targetAndTransition, true);\n  }\n\n  useEffect(function () {\n    var targetToAnimate = {}; // These are the values we're actually animating\n\n    var animatingTarget = targetWithoutTransition(targetAndTransition); // This is the target as it'll be once transitionEnd values are applied\n\n    var finalTarget = targetWithoutTransition(targetAndTransition, true); // Detect which values have changed between renders\n\n    for (var key in animatingTarget) {\n      // This value should animate on mount if this value doesn't already exist (wasn't\n      // defined in `style` or `initial`) or if it does exist and it's already changed.\n      var shouldAnimateOnMount = isInitialRender.current && (!visualElement.hasValue(key) || visualElement.getValue(key).get() !== finalTarget[key]); // If this value has updated between renders or it's we're animating this value on mount,\n      // add it to the animate target.\n\n      var isValidValue = finalTarget[key] !== null;\n      var valueHasUpdated = hasUpdated(prevValues.current[key], finalTarget[key]);\n\n      if (isValidValue && (valueHasUpdated || shouldAnimateOnMount)) {\n        targetToAnimate[key] = animatingTarget[key];\n      }\n    }\n\n    isInitialRender.current = false;\n    prevValues.current = __assign(__assign({}, prevValues.current), finalTarget);\n\n    if (Object.keys(targetToAnimate).length) {\n      controls.start(__assign(__assign({}, targetToAnimate), {\n        transition: targetAndTransition.transition || defaultTransition,\n        transitionEnd: targetAndTransition.transitionEnd\n      }));\n    }\n  }, [targetAndTransition]);\n}\n\nvar labelsToArray = function labelsToArray(label) {\n  if (!label) {\n    return [];\n  }\n\n  if (Array.isArray(label)) {\n    return label;\n  }\n\n  return [label];\n};\n\nvar resolveVariantLabels = function resolveVariantLabels(variant) {\n  var unresolvedVariant = variant instanceof MotionValue ? variant.get() : variant;\n  return Array.from(new Set(labelsToArray(unresolvedVariant)));\n};\n/**\n * Hooks in React sometimes accept a dependency array as their final argument. (ie useEffect/useMemo)\n * When values in this array change, React re-runs the dependency. However if the array\n * contains a variable number of items, React throws an error.\n */\n\n\nvar asDependencyList = function asDependencyList(list) {\n  return [list.join(\",\")];\n};\n\nvar hasVariantChanged = function hasVariantChanged(oldVariant, newVariant) {\n  return oldVariant.join(\",\") !== newVariant.join(\",\");\n};\n/**\n * Handle variants and the `animate` prop when its set as variant labels.\n *\n * @param initial - Initial variant(s)\n * @param animate - Variant(s) to animate to\n * @param inherit - `true` is inheriting animations from parent\n * @param controls - Animation controls\n *\n * @internal\n */\n\n\nfunction useVariants(initial, animate, inherit, controls) {\n  var targetVariants = resolveVariantLabels(animate);\n  var context = useContext(MotionContext);\n  var parentAlreadyMounted = context.hasMounted && context.hasMounted.current;\n  var hasMounted = useRef(false);\n  useEffect(function () {\n    var shouldAnimate = false;\n\n    if (inherit) {\n      // If we're inheriting variant changes and the parent has already\n      // mounted when this component loads, we need to manually trigger\n      // this animation.\n      shouldAnimate = !!parentAlreadyMounted;\n      targetVariants = resolveVariantLabels(context.animate);\n    } else {\n      shouldAnimate = hasMounted.current || hasVariantChanged(resolveVariantLabels(initial), targetVariants);\n    }\n\n    shouldAnimate && controls.start(targetVariants);\n    hasMounted.current = true;\n  }, asDependencyList(targetVariants));\n}\n/**\n * `useAnimationGroupSubscription` allows a component to subscribe to an\n * externally-created `AnimationControls`, created by the `useAnimation` hook.\n *\n * @param animation\n * @param controls\n *\n * @internal\n */\n\n\nfunction useAnimationGroupSubscription(animation, controls) {\n  var unsubscribe = useMemo(function () {\n    return animation.subscribe(controls);\n  }, [animation]);\n  useEffect(function () {\n    return function () {\n      unsubscribe && unsubscribe();\n    };\n  }, [unsubscribe]);\n}\n\nvar _a, _b;\n\nvar AnimatePropComponents = (_a = {}, _a[AnimatePropType.Target] = makeRenderlessComponent(function (_a) {\n  var animate = _a.animate,\n      controls = _a.controls,\n      visualElement = _a.visualElement,\n      transition = _a.transition;\n  return useAnimateProp(animate, controls, visualElement, transition);\n}), _a[AnimatePropType.VariantLabel] = makeRenderlessComponent(function (_a) {\n  var animate = _a.animate,\n      _b = _a.inherit,\n      inherit = _b === void 0 ? true : _b,\n      controls = _a.controls,\n      initial = _a.initial;\n  return useVariants(initial, animate, inherit, controls);\n}), _a[AnimatePropType.AnimationSubscription] = makeRenderlessComponent(function (_a) {\n  var animate = _a.animate,\n      controls = _a.controls;\n  return useAnimationGroupSubscription(animate, controls);\n}), _a);\n\nvar isVariantLabel$1 = function isVariantLabel$1(prop) {\n  return Array.isArray(prop) || typeof prop === \"string\";\n};\n\nvar isAnimationSubscription = function isAnimationSubscription(_a) {\n  var animate = _a.animate;\n  return animate instanceof AnimationControls;\n};\n\nvar animationProps = [\"initial\", \"animate\", \"whileTap\", \"whileHover\"];\nvar animatePropTypeTests = (_b = {}, _b[AnimatePropType.Target] = function (props) {\n  return props.animate !== undefined && !isVariantLabel$1(props.animate) && !isAnimationSubscription(props);\n}, _b[AnimatePropType.VariantLabel] = function (props) {\n  return props.variants !== undefined || animationProps.some(function (key) {\n    return typeof props[key] === \"string\";\n  });\n}, _b[AnimatePropType.AnimationSubscription] = isAnimationSubscription, _b);\n\nvar getAnimationComponent = function getAnimationComponent(props) {\n  var animatePropType = undefined;\n\n  for (var key in AnimatePropType) {\n    if (animatePropTypeTests[key](props)) {\n      animatePropType = key;\n    }\n  }\n\n  return animatePropType ? AnimatePropComponents[animatePropType] : undefined;\n};\n\nfunction tweenAxis(target, prev, next, p) {\n  target.min = mix(prev.min, next.min, p);\n  target.max = mix(prev.max, next.max, p);\n}\n\nvar Presence;\n\n(function (Presence) {\n  Presence[Presence[\"Entering\"] = 0] = \"Entering\";\n  Presence[Presence[\"Present\"] = 1] = \"Present\";\n  Presence[Presence[\"Exiting\"] = 2] = \"Exiting\";\n})(Presence || (Presence = {}));\n\nvar VisibilityAction;\n\n(function (VisibilityAction) {\n  VisibilityAction[VisibilityAction[\"Hide\"] = 0] = \"Hide\";\n  VisibilityAction[VisibilityAction[\"Show\"] = 1] = \"Show\";\n})(VisibilityAction || (VisibilityAction = {}));\n\nvar progressTarget = 1000;\n\nvar Animate =\n/** @class */\nfunction (_super) {\n  __extends(Animate, _super);\n\n  function Animate() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.frameTarget = {\n      x: {\n        min: 0,\n        max: 0\n      },\n      y: {\n        min: 0,\n        max: 0\n      }\n    };\n    _this.stopAxisAnimation = {\n      x: undefined,\n      y: undefined\n    };\n\n    _this.animate = function (target, origin, _a) {\n      if (_a === void 0) {\n        _a = {};\n      }\n\n      var originBox = _a.originBox,\n          targetBox = _a.targetBox,\n          visibilityAction = _a.visibilityAction,\n          config = __rest(_a, [\"originBox\", \"targetBox\", \"visibilityAction\"]);\n\n      var _b = _this.props,\n          visualElement = _b.visualElement,\n          layout = _b.layout;\n      /**\n       * Allow the measured origin (prev bounding box) and target (actual layout) to be\n       * overridden by the provided config.\n       */\n\n      origin = originBox || origin;\n      target = targetBox || target;\n      var boxHasMoved = hasMoved(origin, target);\n      var animations = eachAxis(function (axis) {\n        /**\n         * If layout is set to \"position\", we can resize the origin box based on the target\n         * box and only animate its position.\n         */\n        if (layout === \"position\") {\n          var targetLength = target[axis].max - target[axis].min;\n          origin[axis].max = origin[axis].min + targetLength;\n        }\n\n        if (visualElement.isTargetBoxLocked) {\n          return;\n        } else if (visibilityAction !== undefined) {\n          // If we're meant to show/hide the visualElement, do so\n          visibilityAction === VisibilityAction.Hide ? visualElement.hide() : visualElement.show();\n        } else if (boxHasMoved) {\n          // If the box has moved, animate between it's current visual state and its\n          // final state\n          return _this.animateAxis(axis, target[axis], origin[axis], config);\n        } else {\n          // If the box has remained in the same place, immediately set the axis target\n          // to the final desired state\n          return visualElement.setAxisTarget(axis, target[axis].min, target[axis].max);\n        }\n      }); // Force a render to ensure there's no flash of uncorrected bounding box.\n\n      visualElement.render();\n      /**\n       * If this visualElement isn't present (ie it's been removed from the tree by the user but\n       * kept in by the tree by AnimatePresence) then call safeToRemove when all axis animations\n       * have successfully finished.\n       */\n\n      return Promise.all(animations).then(function () {\n        var _a, _b;\n\n        (_a = config.onLayoutAnimationComplete) === null || _a === void 0 ? void 0 : _a.call(config);\n\n        if (visualElement.isPresent) {\n          visualElement.presence = Presence.Present;\n        } else {\n          (_b = config.onLayoutAnimationComplete) === null || _b === void 0 ? void 0 : _b.call(config);\n\n          _this.safeToRemove();\n        }\n      });\n    };\n\n    return _this;\n  }\n\n  Animate.prototype.componentDidMount = function () {\n    var visualElement = this.props.visualElement;\n    visualElement.enableLayoutProjection();\n    this.unsubLayoutReady = visualElement.onLayoutUpdate(this.animate);\n  };\n\n  Animate.prototype.componentWillUnmount = function () {\n    var _this = this;\n\n    this.unsubLayoutReady();\n    eachAxis(function (axis) {\n      var _a, _b;\n\n      return (_b = (_a = _this.stopAxisAnimation)[axis]) === null || _b === void 0 ? void 0 : _b.call(_a);\n    });\n  };\n  /**\n   * TODO: This manually performs animations on the visualElement's layout progress\n   * values. It'd be preferable to amend the HTMLVisualElement.startLayoutAxisAnimation\n   * API to accept more custom animations like this.\n   */\n\n\n  Animate.prototype.animateAxis = function (axis, target, origin, _a) {\n    var _b, _c;\n\n    var _d = _a === void 0 ? {} : _a,\n        transition = _d.transition,\n        crossfadeOpacity = _d.crossfadeOpacity;\n\n    (_c = (_b = this.stopAxisAnimation)[axis]) === null || _c === void 0 ? void 0 : _c.call(_b);\n    var visualElement = this.props.visualElement;\n    var frameTarget = this.frameTarget[axis];\n    var layoutProgress = visualElement.axisProgress[axis];\n    /**\n     * Set layout progress back to 0. We set it twice to hard-reset any velocity that might\n     * be re-incoporated into a subsequent spring animation.\n     */\n\n    layoutProgress.clearListeners();\n    layoutProgress.set(0);\n    layoutProgress.set(0);\n    /**\n     * If this is a crossfade animation, create a function that updates both the opacity of this component\n     * and the one being crossfaded out.\n     */\n\n    var crossfade = crossfadeOpacity && this.createCrossfadeAnimation(crossfadeOpacity);\n    /**\n     * Create an animation function to run once per frame. This will tween the visual bounding box from\n     * origin to target using the latest progress value.\n     */\n\n    var frame = function frame() {\n      // Convert the latest layoutProgress, which is a value from 0-1000, into a 0-1 progress\n      var p = layoutProgress.get() / progressTarget; // Tween the axis and update the visualElement with the latest values\n\n      tweenAxis(frameTarget, origin, target, p);\n      visualElement.setAxisTarget(axis, frameTarget.min, frameTarget.max); // If this is a crossfade animation, update both elements.\n\n      crossfade === null || crossfade === void 0 ? void 0 : crossfade(p);\n    }; // Synchronously run a frame to ensure there's no flash of the uncorrected bounding box.\n\n\n    frame(); // Start the animation on this axis\n\n    var animation = startAnimation(axis === \"x\" ? \"layoutX\" : \"layoutY\", layoutProgress, progressTarget, transition || this.props.transition || defaultTransition); // Create a function to stop animation on this specific axis\n\n    var unsubscribeProgress = layoutProgress.onChange(frame);\n\n    this.stopAxisAnimation[axis] = function () {\n      layoutProgress.stop();\n      unsubscribeProgress();\n    };\n\n    return animation;\n  };\n\n  Animate.prototype.createCrossfadeAnimation = function (crossfadeOpacity) {\n    var visualElement = this.props.visualElement;\n    var opacity = visualElement.getValue(\"opacity\", 0);\n    return function (p) {\n      opacity.set(easeCrossfadeIn(mix(0, 1, p)));\n      crossfadeOpacity.set(easeCrossfadeOut(mix(1, 0, p)));\n    };\n  };\n\n  Animate.prototype.safeToRemove = function () {\n    var _a, _b;\n\n    (_b = (_a = this.props).safeToRemove) === null || _b === void 0 ? void 0 : _b.call(_a);\n  };\n\n  Animate.prototype.render = function () {\n    return null;\n  };\n\n  return Animate;\n}(Component);\n\nvar AnimateLayout = {\n  key: \"animate-layout\",\n  shouldRender: function shouldRender(props) {\n    return !!props.layout || !!props.layoutId;\n  },\n  Component: function Component(props) {\n    var _a = usePresence(),\n        safeToRemove = _a[1];\n\n    return createElement(Animate, __assign({}, props, {\n      safeToRemove: safeToRemove\n    }));\n  }\n};\n\nfunction hasMoved(a, b) {\n  return hasAxisMoved(a.x, b.x) || hasAxisMoved(a.y, b.y);\n}\n\nfunction hasAxisMoved(a, b) {\n  return a.min !== b.min || a.max !== b.max;\n}\n\nvar defaultTransition = {\n  duration: 0.45,\n  ease: [0.4, 0, 0.1, 1]\n};\n\nfunction compress(min, max, easing) {\n  return function (p) {\n    // Could replace ifs with clamp\n    if (p < min) return 0;\n    if (p > max) return 1;\n    return easing(progress(min, max, p));\n  };\n}\n\nvar easeCrossfadeIn = compress(0, 0.5, circOut);\nvar easeCrossfadeOut = compress(0.5, 0.95, linear$1);\n/**\n * Default handlers for batching VisualElements\n */\n\nvar defaultHandler = {\n  measureLayout: function measureLayout(child) {\n    return child.measureLayout();\n  },\n  layoutReady: function layoutReady(child) {\n    return child.layoutReady();\n  }\n};\n/**\n * Sort VisualElements by tree depth, so we process the highest elements first.\n */\n\nvar sortByDepth = function sortByDepth(a, b) {\n  return a.depth - b.depth;\n};\n/**\n * Create a batcher to process VisualElements\n */\n\n\nfunction createBatcher() {\n  var queue = new Set();\n\n  var add = function add(child) {\n    return queue.add(child);\n  };\n\n  var flush = function flush(_a) {\n    var _b = _a === void 0 ? defaultHandler : _a,\n        measureLayout = _b.measureLayout,\n        layoutReady = _b.layoutReady;\n\n    var order = Array.from(queue).sort(sortByDepth);\n    /**\n     * Write: Reset any transforms on children elements so we can read their actual layout\n     */\n\n    order.forEach(function (child) {\n      return child.resetTransform();\n    });\n    /**\n     * Read: Measure the actual layout\n     */\n\n    order.forEach(measureLayout);\n    /**\n     * Write: Notify the VisualElements they're ready for further write operations.\n     */\n\n    order.forEach(layoutReady);\n    /**\n     * After all children have started animating, ensure any Entering components are set to Present.\n     * If we add deferred animations (set up all animations and then start them in two loops) this\n     * could be moved to the start loop. But it needs to happen after all the animations configs\n     * are generated in AnimateSharedLayout as this relies on presence data\n     */\n\n    order.forEach(function (child) {\n      if (child.isPresent) child.presence = Presence.Present;\n    });\n    queue.clear();\n  };\n\n  return {\n    add: add,\n    flush: flush\n  };\n}\n\nfunction isSharedLayout(context) {\n  return !!context.forceUpdate;\n}\n\nvar SharedLayoutContext = createContext(createBatcher());\n/**\n * This component is responsible for scheduling the measuring of the motion component\n */\n\nvar Measure =\n/** @class */\nfunction (_super) {\n  __extends(Measure, _super);\n\n  function Measure(props) {\n    var _this = _super.call(this, props) || this;\n    /**\n     * If this component isn't the child of a SyncContext, make it responsible for flushing\n     * the layout batcher\n     */\n\n\n    var syncLayout = props.syncLayout;\n\n    if (!isSharedLayout(syncLayout)) {\n      _this.componentDidUpdate = function () {\n        return syncLayout.flush();\n      };\n    }\n\n    return _this;\n  }\n  /**\n   * If this is a child of a SyncContext, register the VisualElement with it on mount.\n   */\n\n\n  Measure.prototype.componentDidMount = function () {\n    var _a = this.props,\n        syncLayout = _a.syncLayout,\n        visualElement = _a.visualElement;\n    isSharedLayout(syncLayout) && syncLayout.register(visualElement);\n  };\n  /**\n   * If this is a child of a SyncContext, notify it that it needs to re-render. It will then\n   * handle the snapshotting.\n   *\n   * If it is stand-alone component, add it to the batcher.\n   */\n\n\n  Measure.prototype.getSnapshotBeforeUpdate = function () {\n    var _a = this.props,\n        syncLayout = _a.syncLayout,\n        visualElement = _a.visualElement;\n\n    if (isSharedLayout(syncLayout)) {\n      syncLayout.syncUpdate();\n    } else {\n      visualElement.snapshotBoundingBox();\n      syncLayout.add(visualElement);\n    }\n\n    return null;\n  };\n\n  Measure.prototype.componentDidUpdate = function () {};\n\n  Measure.prototype.render = function () {\n    return null;\n  };\n\n  return Measure;\n}(React__default.Component);\n\nvar MeasureLayout = {\n  key: \"measure-layout\",\n  shouldRender: function shouldRender(props) {\n    return !!props.drag || !!props.layout || !!props.layoutId;\n  },\n  Component: function Component(props) {\n    var syncLayout = useContext(SharedLayoutContext);\n    return React__default.createElement(Measure, __assign({}, props, {\n      syncLayout: syncLayout\n    }));\n  }\n};\n/**\n * Currently we load all features synchronously, but it would be better to offer multiple entry points\n * that allow these to be loaded in asynchronously.\n */\n\nvar defaultFeatures = [MeasureLayout, Drag, Gestures, Exit, AnimateLayout];\n/**\n * Load features via renderless components based on the provided MotionProps\n */\n\nfunction useFeatures(isStatic, visualElement, controls, props, context, parentContext, shouldInheritVariant) {\n  var plugins = useContext(MotionPluginContext); // If this is a static component, or we're rendering on the server, we don't load\n  // any feature components\n\n  if (isStatic || typeof window === \"undefined\") return null;\n\n  var allFeatures = __spreadArrays(defaultFeatures, plugins.features);\n\n  var numFeatures = allFeatures.length;\n  var features = []; // TODO: Consolidate Animation feature loading strategy with other functionality components\n\n  var Animation = getAnimationComponent(props);\n\n  if (Animation) {\n    features.push(createElement(Animation, {\n      key: \"animation\",\n      initial: props.initial,\n      animate: props.animate,\n      variants: props.variants,\n      transition: props.transition,\n      controls: controls,\n      inherit: shouldInheritVariant,\n      visualElement: visualElement\n    }));\n  } // Decide which features we should render and add them to the returned array\n\n\n  for (var i = 0; i < numFeatures; i++) {\n    var _a = allFeatures[i],\n        shouldRender = _a.shouldRender,\n        key = _a.key,\n        Component = _a.Component;\n\n    if (shouldRender(props, parentContext)) {\n      features.push(createElement(Component, __assign({\n        key: key\n      }, props, {\n        localContext: context,\n        parentContext: parentContext,\n        visualElement: visualElement,\n        controls: controls\n      })));\n    }\n  }\n\n  return features;\n}\n\nfunction useSnapshotOnUnmount(visualElement) {\n  var syncLayout = useContext(SharedLayoutContext);\n  useUnmountEffect(function () {\n    if (isSharedLayout(syncLayout)) syncLayout.remove(visualElement);\n  });\n}\n/**\n * Create a `motion` component.\n *\n * This function accepts a Component argument, which can be either a string (ie \"div\"\n * for `motion.div`), or an actual React component.\n *\n * Alongside this is a config option which provides a way of rendering the provided\n * component \"offline\", or outside the React render cycle.\n *\n * @internal\n */\n\n\nfunction createMotionComponent(Component, _a) {\n  var useVisualElement = _a.useVisualElement,\n      render = _a.render,\n      animationControlsConfig = _a.animationControlsConfig;\n\n  function MotionComponent(props, externalRef) {\n    var parentContext = useContext(MotionContext);\n    var shouldInheritVariant = checkShouldInheritVariant(props);\n    /**\n     * If a component isStatic, we only visually update it as a\n     * result of a React re-render, rather than any interactions or animations.\n     * If this component or any ancestor isStatic, we disable hardware acceleration\n     * and don't load any additional functionality.\n     */\n\n    var isStatic = parentContext[\"static\"] || props[\"static\"] || false;\n    /**\n     * Create a VisualElement for this component. A VisualElement provides a common\n     * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as\n     * providing a way of rendering to these APIs outside of the React render loop\n     * for more performant animations and interactions\n     */\n\n    var visualElement = useVisualElement(Component, props, parentContext.visualElement, isStatic, externalRef);\n    /**\n     * Scrape MotionValues from props and add/remove them to/from\n     * the VisualElement as necessary.\n     */\n\n    useMotionValues(visualElement, props);\n    /**\n     * Create animation controls for the VisualElement. It might be\n     * interesting to try and combine this with VisualElement itself in a further refactor.\n     */\n\n    var controls = useVisualElementAnimation(visualElement, props, animationControlsConfig);\n    /**\n     * Build the MotionContext to pass on to the next `motion` component.\n     */\n\n    var context = useMotionContext(parentContext, controls, visualElement, isStatic, props);\n    /**\n     * Load features as renderless components unless the component isStatic\n     */\n\n    var features = useFeatures(isStatic, visualElement, controls, props, context, parentContext, shouldInheritVariant);\n    var component = render(Component, props, visualElement);\n    /**\n     *\n     */\n\n    useSnapshotOnUnmount(visualElement); // The mount order and hierarchy is specific to ensure our element ref is hydrated by the time\n    // all plugins and features has to execute.\n\n    return createElement(Fragment, null, createElement(MotionContext.Provider, {\n      value: context\n    }, component), features);\n  }\n\n  return forwardRef(MotionComponent);\n}\n/**\n * DOM-specific config for `motion` components\n */\n\n\nvar config = {\n  useVisualElement: useDomVisualElement,\n  render: render,\n  animationControlsConfig: {\n    makeTargetAnimatable: parseDomVariant\n  }\n};\n/**\n * Convert any React component into a `motion` component. The provided component\n * **must** use `React.forwardRef` to the underlying DOM component you want to animate.\n *\n * ```jsx\n * const Component = React.forwardRef((props, ref) => {\n *   return <div ref={ref} />\n * })\n *\n * const MotionComponent = motion.custom(Component)\n * ```\n *\n * @public\n */\n\nfunction custom(Component) {\n  return createMotionComponent(Component, config);\n}\n\nvar componentCache = new Map();\n\nfunction get(target, key) {\n  if (key === \"custom\") return target.custom;\n\n  if (!componentCache.has(key)) {\n    componentCache.set(key, createMotionComponent(key, config));\n  }\n\n  return componentCache.get(key);\n}\n/**\n * HTML & SVG components, optimised for use with gestures and animation. These can be used as\n * drop-in replacements for any HTML & SVG component, all CSS & SVG properties are supported.\n *\n * @public\n */\n\n\nvar motion = new Proxy({\n  custom: custom\n}, {\n  get: get\n});\n\nfunction useForceUpdate() {\n  var _a = useState(0),\n      forcedRenderCount = _a[0],\n      setForcedRenderCount = _a[1];\n\n  return useCallback(function () {\n    return setForcedRenderCount(forcedRenderCount + 1);\n  }, [forcedRenderCount]);\n}\n\nvar presenceId = 0;\n\nfunction getPresenceId() {\n  var id = presenceId;\n  presenceId++;\n  return id;\n}\n\nvar PresenceChild = function PresenceChild(_a) {\n  var children = _a.children,\n      initial = _a.initial,\n      isPresent = _a.isPresent,\n      _onExitComplete = _a.onExitComplete,\n      custom = _a.custom;\n  var presenceChildren = useConstant(newChildrenMap);\n  var context = {\n    id: useConstant(getPresenceId),\n    initial: initial,\n    isPresent: isPresent,\n    custom: custom,\n    onExitComplete: function onExitComplete(childId) {\n      presenceChildren.set(childId, true);\n      var allComplete = true;\n      presenceChildren.forEach(function (isComplete) {\n        if (!isComplete) allComplete = false;\n      });\n      allComplete && (_onExitComplete === null || _onExitComplete === void 0 ? void 0 : _onExitComplete());\n    },\n    register: function register(childId) {\n      presenceChildren.set(childId, false);\n      return function () {\n        return presenceChildren[\"delete\"](childId);\n      };\n    }\n  };\n  useMemo(function () {\n    presenceChildren.forEach(function (_, key) {\n      return presenceChildren.set(key, false);\n    });\n  }, [isPresent]);\n  return createElement(PresenceContext.Provider, {\n    value: context\n  }, children);\n};\n\nfunction newChildrenMap() {\n  return new Map();\n}\n\nfunction getChildKey(child) {\n  return child.key || \"\";\n}\n\nfunction updateChildLookup(children, allChildren) {\n  var seenChildren = process.env.NODE_ENV !== \"production\" ? new Set() : null;\n  children.forEach(function (child) {\n    var key = getChildKey(child);\n\n    if (process.env.NODE_ENV !== \"production\" && seenChildren) {\n      if (seenChildren.has(key)) {\n        console.warn(\"Children of AnimatePresence require unique keys. \\\"\" + key + \"\\\" is a duplicate.\");\n      }\n\n      seenChildren.add(key);\n    }\n\n    allChildren.set(key, child);\n  });\n}\n\nfunction onlyElements(children) {\n  var filtered = []; // We use forEach here instead of map as map mutates the component key by preprending `.$`\n\n  Children.forEach(children, function (child) {\n    if (isValidElement(child)) filtered.push(child);\n  });\n  return filtered;\n}\n/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * @library\n *\n * Any `Frame` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { Frame, AnimatePresence } from 'framer'\n *\n * // As items are added and removed from `items`\n * export function Items({ items }) {\n *   return (\n *     <AnimatePresence>\n *       {items.map(item => (\n *         <Frame\n *           key={item.id}\n *           initial={{ opacity: 0 }}\n *           animate={{ opacity: 1 }}\n *           exit={{ opacity: 0 }}\n *         />\n *       ))}\n *     </AnimatePresence>\n *   )\n * }\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * @motion\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from 'framer-motion'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */\n\n\nvar AnimatePresence = function AnimatePresence(_a) {\n  var children = _a.children,\n      custom = _a.custom,\n      _b = _a.initial,\n      initial = _b === void 0 ? true : _b,\n      onExitComplete = _a.onExitComplete,\n      exitBeforeEnter = _a.exitBeforeEnter; // We want to force a re-render once all exiting animations have finished. We\n  // either use a local forceRender function, or one from a parent context if it exists.\n\n  var forceRender = useForceUpdate();\n  var layoutContext = useContext(SharedLayoutContext);\n\n  if (isSharedLayout(layoutContext)) {\n    forceRender = layoutContext.forceUpdate;\n  }\n\n  var isInitialRender = useRef(true); // Filter out any children that aren't ReactElements. We can only track ReactElements with a props.key\n\n  var filteredChildren = onlyElements(children); // Keep a living record of the children we're actually rendering so we\n  // can diff to figure out which are entering and exiting\n\n  var presentChildren = useRef(filteredChildren); // A lookup table to quickly reference components by key\n\n  var allChildren = useRef(new Map()).current; // A living record of all currently exiting components.\n\n  var exiting = useRef(new Set()).current;\n  updateChildLookup(filteredChildren, allChildren); // If this is the initial component render, just deal with logic surrounding whether\n  // we play onMount animations or not.\n\n  if (isInitialRender.current) {\n    isInitialRender.current = false;\n    return createElement(Fragment, null, filteredChildren.map(function (child) {\n      return createElement(PresenceChild, {\n        key: getChildKey(child),\n        isPresent: true,\n        initial: initial ? undefined : false\n      }, child);\n    }));\n  } // If this is a subsequent render, deal with entering and exiting children\n\n\n  var childrenToRender = __spreadArrays(filteredChildren); // Diff the keys of the currently-present and target children to update our\n  // exiting list.\n\n\n  var presentKeys = presentChildren.current.map(getChildKey);\n  var targetKeys = filteredChildren.map(getChildKey); // Diff the present children with our target children and mark those that are exiting\n\n  var numPresent = presentKeys.length;\n\n  for (var i = 0; i < numPresent; i++) {\n    var key = presentKeys[i];\n\n    if (targetKeys.indexOf(key) === -1) {\n      exiting.add(key);\n    } else {\n      // In case this key has re-entered, remove from the exiting list\n      exiting[\"delete\"](key);\n    }\n  } // If we currently have exiting children, and we're deferring rendering incoming children\n  // until after all current children have exiting, empty the childrenToRender array\n\n\n  if (exitBeforeEnter && exiting.size) {\n    childrenToRender = [];\n  } // Loop through all currently exiting components and clone them to overwrite `animate`\n  // with any `exit` prop they might have defined.\n\n\n  exiting.forEach(function (key) {\n    // If this component is actually entering again, early return\n    if (targetKeys.indexOf(key) !== -1) return;\n    var child = allChildren.get(key);\n    if (!child) return;\n    var insertionIndex = presentKeys.indexOf(key);\n\n    var onExit = function onExit() {\n      allChildren[\"delete\"](key);\n      exiting[\"delete\"](key); // Remove this child from the present children\n\n      var removeIndex = presentChildren.current.findIndex(function (presentChild) {\n        return presentChild.key === key;\n      });\n      presentChildren.current.splice(removeIndex, 1); // Defer re-rendering until all exiting children have indeed left\n\n      if (!exiting.size) {\n        presentChildren.current = filteredChildren;\n        forceRender();\n        onExitComplete && onExitComplete();\n      }\n    };\n\n    childrenToRender.splice(insertionIndex, 0, createElement(PresenceChild, {\n      key: getChildKey(child),\n      isPresent: false,\n      onExitComplete: onExit,\n      custom: custom\n    }, child));\n  }); // Add `MotionContext` even to children that don't need it to ensure we're rendering\n  // the same tree between renders\n\n  childrenToRender = childrenToRender.map(function (child) {\n    var key = child.key;\n    return exiting.has(key) ? child : createElement(PresenceChild, {\n      key: getChildKey(child),\n      isPresent: true\n    }, child);\n  });\n  presentChildren.current = childrenToRender;\n\n  if (process.env.NODE_ENV !== \"production\" && exitBeforeEnter && childrenToRender.length > 1) {\n    console.warn(\"You're attempting to animate multiple children within AnimatePresence, but its exitBeforeEnter prop is set to true. This will lead to odd visual behaviour.\");\n  }\n\n  return createElement(Fragment, null, exiting.size ? childrenToRender : childrenToRender.map(function (child) {\n    return cloneElement(child);\n  }));\n};\n\nfunction createSwitchAnimation(child, stack) {\n  if (stack && child !== stack.lead) {\n    return {\n      visibilityAction: VisibilityAction.Hide\n    };\n  } else if (stack && child.presence !== Presence.Entering && child === stack.lead && stack.lead !== stack.prevLead) {\n    return {\n      visibilityAction: VisibilityAction.Show\n    };\n  }\n\n  var originBox;\n  var targetBox;\n\n  if (child.presence === Presence.Entering) {\n    originBox = stack === null || stack === void 0 ? void 0 : stack.getFollowOrigin();\n  } else if (child.presence === Presence.Exiting) {\n    targetBox = stack === null || stack === void 0 ? void 0 : stack.getFollowTarget();\n  }\n\n  return {\n    originBox: originBox,\n    targetBox: targetBox\n  };\n}\n\nfunction createCrossfadeAnimation(child, stack) {\n  var _a, _b, _c;\n\n  var config = {};\n  var stackLead = stack && stack.lead;\n  var stackLeadPresence = stackLead === null || stackLead === void 0 ? void 0 : stackLead.presence;\n\n  if (stack && child === stackLead) {\n    if (child.presence === Presence.Entering) {\n      config.originBox = stack.getFollowOrigin();\n    } else if (child.presence === Presence.Exiting) {\n      config.targetBox = stack.getFollowTarget();\n    }\n  } else if (stack && child === stack.follow) {\n    config.transition = stack.getLeadTransition();\n\n    if (stackLeadPresence === Presence.Entering) {\n      config.targetBox = stack.getLeadTarget();\n    } else if (stackLeadPresence === Presence.Exiting) {\n      config.originBox = stack.getLeadOrigin();\n    }\n  } // If neither the lead or follow component is the root child of AnimatePresence,\n  // don't handle crossfade animations\n\n\n  if (!((_a = stack === null || stack === void 0 ? void 0 : stack.follow) === null || _a === void 0 ? void 0 : _a.isPresenceRoot) && !(stackLead === null || stackLead === void 0 ? void 0 : stackLead.isPresenceRoot)) {\n    return config;\n  }\n\n  if (!stack || child === stackLead) {\n    if (child.presence === Presence.Entering) {\n      config.crossfadeOpacity = (_b = stack === null || stack === void 0 ? void 0 : stack.follow) === null || _b === void 0 ? void 0 : _b.getValue(\"opacity\", 0);\n    }\n  } else if (stack && child === stack.follow) {\n    if (!stackLead || stackLeadPresence === Presence.Entering) ;else if (stackLeadPresence === Presence.Exiting) {\n      config.crossfadeOpacity = (_c = stack === null || stack === void 0 ? void 0 : stack.lead) === null || _c === void 0 ? void 0 : _c.getValue(\"opacity\", 1);\n    }\n  } else {\n    config.visibilityAction = VisibilityAction.Hide;\n  }\n\n  return config;\n}\n/**\n * For each layout animation, we want to identify two components\n * within a stack that will serve as the \"lead\" and \"follow\" components.\n *\n * In the switch animation, the lead component performs the entire animation.\n * It uses the follow bounding box to animate out from and back to. The follow\n * component is hidden.\n *\n * In the crossfade animation, both the lead and follow components perform\n * the entire animation, animating from the follow origin bounding box to the lead\n * target bounding box.\n *\n * Generalising a stack as First In Last Out, *searching from the end* we can\n * generally consider the lead component to be:\n *  - If the last child is present, the last child\n *  - If the last child is exiting, the last *encountered* exiting component\n */\n\n\nfunction findLeadAndFollow(stack, _a) {\n  var prevLead = _a[0],\n      prevFollow = _a[1];\n  var lead = undefined;\n  var leadIndex = 0;\n  var follow = undefined; // Find the lead child first\n\n  var numInStack = stack.length;\n  var lastIsPresent = false;\n\n  for (var i = numInStack - 1; i >= 0; i--) {\n    var child = stack[i];\n    var isLastInStack = i === numInStack - 1;\n    if (isLastInStack) lastIsPresent = child.isPresent;\n\n    if (lastIsPresent) {\n      lead = child;\n    } else {\n      // If the child before this will be present, make this the\n      // lead.\n      var prev = stack[i - 1];\n      if (prev && prev.isPresent) lead = child;\n    }\n\n    if (lead) {\n      leadIndex = i;\n      break;\n    }\n  }\n\n  if (!lead) lead = stack[0]; // Find the follow child\n\n  follow = stack[leadIndex - 1]; // If the lead component is exiting, find the closest follow\n  // present component\n\n  if (lead) {\n    for (var i = leadIndex - 1; i >= 0; i--) {\n      var child = stack[i];\n\n      if (child.isPresent) {\n        follow = child;\n        break;\n      }\n    }\n  } // If the lead has changed and the previous lead still exists in the\n  // stack, set it to the previous lead. This allows us to differentiate between\n  // a, b, c(exit) -> a, b(exit), c(exit)\n  // and\n  // a, b(exit), c -> a, b(exit), c(exit)\n\n\n  if (lead !== prevLead && !lastIsPresent && follow === prevFollow && stack.find(function (stackChild) {\n    return stackChild === prevLead;\n  })) {\n    lead = prevLead;\n  }\n\n  return [lead, follow];\n}\n\nvar LayoutStack =\n/** @class */\nfunction () {\n  function LayoutStack() {\n    this.order = []; // Track whether we've ever had a child\n\n    this.hasChildren = false;\n  }\n\n  LayoutStack.prototype.add = function (child) {\n    var _a;\n\n    var layoutOrder = child.config.layoutOrder;\n\n    if (layoutOrder === undefined) {\n      this.order.push(child);\n    } else {\n      var index = this.order.findIndex(function (stackChild) {\n        return layoutOrder <= (stackChild.config.layoutOrder || 0);\n      });\n\n      if (index === -1) {\n        child.presence = this.hasChildren ? Presence.Entering : Presence.Present;\n        index = this.order.length;\n      }\n\n      this.order.splice(index, 0, child);\n    }\n    /**\n     *\n     */\n    // Load previous values from snapshot into this child\n    // TODO Neaten up\n    // TODO Double check when reimplementing move\n    // TODO Add isDragging status and\n\n\n    if (this.snapshot) {\n      child.prevSnapshot = this.snapshot; // TODO Remove in favour of above\n\n      child.prevViewportBox = this.snapshot.boundingBox;\n      var latest = this.snapshot.latestMotionValues;\n\n      for (var key in latest) {\n        if (!child.hasValue(key)) {\n          child.addValue(key, motionValue(latest[key]));\n        } else {\n          (_a = child.getValue(key)) === null || _a === void 0 ? void 0 : _a.set(latest[key]);\n        }\n      }\n    }\n\n    this.hasChildren = true;\n  };\n\n  LayoutStack.prototype.remove = function (child) {\n    var index = this.order.findIndex(function (stackChild) {\n      return child === stackChild;\n    });\n    if (index !== -1) this.order.splice(index, 1);\n  };\n\n  LayoutStack.prototype.updateLeadAndFollow = function () {\n    this.prevLead = this.lead;\n    this.prevFollow = this.follow;\n\n    var _a = findLeadAndFollow(this.order, [this.lead, this.follow]),\n        lead = _a[0],\n        follow = _a[1];\n\n    this.lead = lead;\n    this.follow = follow;\n  };\n\n  LayoutStack.prototype.updateSnapshot = function () {\n    if (!this.lead) return;\n    var snapshot = {\n      boundingBox: this.lead.prevViewportBox,\n      latestMotionValues: {}\n    };\n    this.lead.forEachValue(function (value, key) {\n      var latest = value.get();\n\n      if (!isTransformProp(latest)) {\n        snapshot.latestMotionValues[key] = latest;\n      }\n    });\n    var dragControls = elementDragControls.get(this.lead);\n\n    if (dragControls && dragControls.isDragging) {\n      snapshot.isDragging = true;\n      snapshot.cursorProgress = dragControls.cursorProgress;\n    }\n\n    this.snapshot = snapshot;\n  };\n\n  LayoutStack.prototype.isLeadPresent = function () {\n    var _a;\n\n    return this.lead && ((_a = this.lead) === null || _a === void 0 ? void 0 : _a.presence) !== Presence.Exiting;\n  };\n\n  LayoutStack.prototype.shouldStackAnimate = function () {\n    return true; // return this.lead && this.lead?.isPresent\n    //     ? this.lead?.props?._shouldAnimate === true\n    //     : this.follow && this.follow?.props._shouldAnimate === true\n  };\n\n  LayoutStack.prototype.getFollowOrigin = function () {\n    var _a; // This shouldAnimate check is quite specifically a fix for the optimisation made in Framer\n    // where components are kept in the tree ready to be re-used\n\n\n    return this.follow // && this.follow.shouldAnimate\n    ? this.follow.prevViewportBox : (_a = this.snapshot) === null || _a === void 0 ? void 0 : _a.boundingBox;\n  };\n\n  LayoutStack.prototype.getFollowTarget = function () {\n    var _a;\n\n    return (_a = this.follow) === null || _a === void 0 ? void 0 : _a.box;\n  };\n\n  LayoutStack.prototype.getLeadOrigin = function () {\n    var _a;\n\n    return (_a = this.lead) === null || _a === void 0 ? void 0 : _a.prevViewportBox;\n  };\n\n  LayoutStack.prototype.getLeadTarget = function () {\n    var _a;\n\n    return (_a = this.lead) === null || _a === void 0 ? void 0 : _a.box;\n  };\n\n  LayoutStack.prototype.getLeadTransition = function () {\n    var _a;\n\n    return (_a = this.lead) === null || _a === void 0 ? void 0 : _a.config.transition;\n  };\n\n  return LayoutStack;\n}();\n/**\n * @public\n */\n\n\nvar AnimateSharedLayout =\n/** @class */\nfunction (_super) {\n  __extends(AnimateSharedLayout, _super);\n\n  function AnimateSharedLayout() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\n     * A list of all the children in the shared layout\n     */\n\n\n    _this.children = new Set();\n    /**\n     * As animate components with a defined `layoutId` are added/removed to the tree,\n     * we store them in order. When one is added, it will animate out from the\n     * previous one, and when it's removed, it'll animate to the previous one.\n     */\n\n    _this.stacks = new Map();\n    /**\n     * Track whether the component has mounted. If it hasn't, the presence of added children\n     * are set to Present, whereas if it has they're considered Entering\n     */\n\n    _this.hasMounted = false;\n    /**\n     * Track whether we already have an update scheduled. If we don't, we'll run snapshots\n     * and schedule one.\n     */\n\n    _this.updateScheduled = false;\n    /**\n     * Tracks whether we already have a render scheduled. If we don't, we'll force one with this.forceRender\n     */\n\n    _this.renderScheduled = false;\n    /**\n     * The methods provided to all children in the shared layout tree.\n     */\n\n    _this.syncContext = __assign(__assign({}, createBatcher()), {\n      syncUpdate: function syncUpdate(force) {\n        return _this.scheduleUpdate(force);\n      },\n      forceUpdate: function forceUpdate() {\n        // By copying syncContext to itself, when this component re-renders it'll also re-render\n        // all children subscribed to the SharedLayout context.\n        _this.syncContext = __assign({}, _this.syncContext);\n\n        _this.scheduleUpdate(true);\n      },\n      register: function register(child) {\n        return _this.addChild(child);\n      },\n      remove: function remove(child) {\n        return _this.removeChild(child);\n      }\n    });\n    return _this;\n  }\n\n  AnimateSharedLayout.prototype.componentDidMount = function () {\n    this.hasMounted = true;\n    this.updateStacks();\n  };\n\n  AnimateSharedLayout.prototype.componentDidUpdate = function () {\n    this.startLayoutAnimation();\n  };\n\n  AnimateSharedLayout.prototype.shouldComponentUpdate = function () {\n    this.renderScheduled = true;\n    return true;\n  };\n\n  AnimateSharedLayout.prototype.startLayoutAnimation = function () {\n    var _this = this;\n    /**\n     * Reset update and render scheduled status\n     */\n\n\n    this.renderScheduled = this.updateScheduled = false;\n    var type = this.props.type;\n    /**\n     * Update presence metadata based on the latest AnimatePresence status.\n     * This is a kind of goofy way of dealing with this, perhaps there's a better model to find.\n     */\n\n    this.children.forEach(function (child) {\n      if (!child.isPresent) {\n        child.presence = Presence.Exiting;\n      } else if (child.presence !== Presence.Entering) {\n        child.presence = child.presence === Presence.Exiting ? Presence.Entering : Presence.Present;\n      }\n    });\n    /**\n     * In every layoutId stack, nominate a component to lead the animation and another\n     * to follow\n     */\n\n    this.updateStacks();\n    /**\n     * Decide which animation to use between shared layoutId components\n     */\n\n    var createAnimation = type === \"crossfade\" ? createCrossfadeAnimation : createSwitchAnimation;\n    /**\n     * Create a handler which we can use to flush the children animations\n     */\n\n    var handler = {\n      measureLayout: function measureLayout(child) {\n        return child.measureLayout();\n      },\n      layoutReady: function layoutReady(child) {\n        var layoutId = child.layoutId;\n        child.layoutReady(createAnimation(child, _this.getStack(layoutId)));\n      }\n    };\n    /**\n     * Shared layout animations can be used without the AnimateSharedLayout wrapping component.\n     * This requires some co-ordination across components to stop layout thrashing\n     * and ensure measurements are taken at the correct time.\n     *\n     * Here we use that same mechanism of schedule/flush.\n     */\n\n    this.children.forEach(function (child) {\n      return _this.syncContext.add(child);\n    });\n    this.syncContext.flush(handler);\n    /**\n     * Clear snapshots so subsequent rerenders don't retain memory of outgoing components\n     */\n\n    this.stacks.forEach(function (stack) {\n      return stack.snapshot = undefined;\n    });\n  };\n\n  AnimateSharedLayout.prototype.updateStacks = function () {\n    this.stacks.forEach(function (stack) {\n      return stack.updateLeadAndFollow();\n    });\n  };\n\n  AnimateSharedLayout.prototype.scheduleUpdate = function (force) {\n    if (force === void 0) {\n      force = false;\n    }\n\n    if (!(force || !this.updateScheduled)) return;\n    /**\n     * Flag we've scheduled an update\n     */\n\n    this.updateScheduled = true;\n    /**\n     * Snapshot children\n     */\n\n    this.children.forEach(function (child) {\n      return child.snapshotBoundingBox();\n    });\n    /**\n     * Every child keeps a local snapshot, but we also want to record\n     * snapshots of the visible children as, if they're are being removed\n     * in this render, we can still access them.\n     */\n\n    this.stacks.forEach(function (stack) {\n      return stack.updateSnapshot();\n    });\n    /**\n     * Force a rerender by setting state if we aren't already going to render.\n     */\n\n    if (force || !this.renderScheduled) {\n      this.renderScheduled = true;\n      this.forceUpdate();\n    }\n  };\n\n  AnimateSharedLayout.prototype.addChild = function (child) {\n    this.children.add(child);\n    this.addToStack(child);\n    child.presence = this.hasMounted ? Presence.Entering : Presence.Present;\n  };\n\n  AnimateSharedLayout.prototype.removeChild = function (child) {\n    this.scheduleUpdate();\n    this.children[\"delete\"](child);\n    this.removeFromStack(child);\n  };\n\n  AnimateSharedLayout.prototype.addToStack = function (child) {\n    var stack = this.getStack(child.layoutId);\n    stack === null || stack === void 0 ? void 0 : stack.add(child);\n  };\n\n  AnimateSharedLayout.prototype.removeFromStack = function (child) {\n    var stack = this.getStack(child.layoutId);\n    stack === null || stack === void 0 ? void 0 : stack.remove(child);\n  };\n  /**\n   * Return a stack of animate children based on the provided layoutId.\n   * Will create a stack if none currently exists with that layoutId.\n   */\n\n\n  AnimateSharedLayout.prototype.getStack = function (id) {\n    if (id === undefined) return; // Create stack if it doesn't already exist\n\n    !this.stacks.has(id) && this.stacks.set(id, new LayoutStack());\n    return this.stacks.get(id);\n  };\n\n  AnimateSharedLayout.prototype.render = function () {\n    return createElement(SharedLayoutContext.Provider, {\n      value: this.syncContext\n    }, this.props.children);\n  };\n\n  return AnimateSharedLayout;\n}(Component);\n/**\n * Creates a `MotionValue` to track the state and velocity of a value.\n *\n * Usually, these are created automatically. For advanced use-cases, like use with `useTransform`, you can create `MotionValue`s externally and pass them into the animated component via the `style` prop.\n *\n * @library\n *\n * ```jsx\n * export function MyComponent() {\n *   const scale = useMotionValue(1)\n *\n *   return <Frame scale={scale} />\n * }\n * ```\n *\n * @motion\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const scale = useMotionValue(1)\n *\n *   return <motion.div style={{ scale }} />\n * }\n * ```\n *\n * @param initial - The initial state.\n *\n * @public\n */\n\n\nfunction useMotionValue(initial) {\n  return useConstant(function () {\n    return motionValue(initial);\n  });\n}\n/**\n * If the provided value is a MotionValue, this returns the actual value, otherwise just the value itself\n *\n * TODO: Remove and move to library\n *\n * @internal\n */\n\n\nfunction resolveMotionValue(value) {\n  var unwrappedValue = value instanceof MotionValue ? value.get() : value;\n  return isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;\n}\n\nvar isCustomValueType = function isCustomValueType(v) {\n  return typeof v === \"object\" && v.mix;\n};\n\nvar getMixer = function getMixer(v) {\n  return isCustomValueType(v) ? v.mix : undefined;\n};\n\nfunction transform() {\n  var args = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    args[_i] = arguments[_i];\n  }\n\n  var useImmediate = !Array.isArray(args[0]);\n  var argOffset = useImmediate ? 0 : -1;\n  var inputValue = args[0 + argOffset];\n  var inputRange = args[1 + argOffset];\n  var outputRange = args[2 + argOffset];\n  var options = args[3 + argOffset];\n  var interpolator = interpolate(inputRange, outputRange, __assign({\n    mixer: getMixer(outputRange[0])\n  }, options));\n  return useImmediate ? interpolator(inputValue) : interpolator;\n}\n\nvar isTransformer = function isTransformer(v) {\n  return typeof v === \"function\";\n};\n\nfunction useTransform(parent, customTransform, to, options) {\n  var comparitor = isTransformer(customTransform) ? [parent] : [parent, customTransform.join(\",\"), to === null || to === void 0 ? void 0 : to.join(\",\")];\n  var transformer = useMemo(function () {\n    return isTransformer(customTransform) ? customTransform : transform(customTransform, to, options);\n  }, comparitor);\n  var initialValue = transformer(parent.get());\n  var value = useMotionValue(initialValue); // Handle subscription to parent\n\n  var unsubscribe = useRef();\n  useMemo(function () {\n    unsubscribe.current && unsubscribe.current();\n    unsubscribe.current = parent.onChange(function (v) {\n      return value.set(transformer(v));\n    }); // Manually set with the latest parent value in case we've re-parented\n\n    value.set(initialValue);\n  }, [parent, value, transformer]);\n  useUnmountEffect(function () {\n    return unsubscribe.current && unsubscribe.current();\n  });\n  return value;\n} // Keep things reasonable and avoid scale: Infinity. In practise we might need\n// to add another value, opacity, that could interpolate scaleX/Y [0,0.01] => [0,1]\n// to simply hide content at unreasonable scales.\n\n\nvar maxScale = 100000;\n\nvar invertScale = function invertScale(scale) {\n  return scale > 0.001 ? 1 / scale : maxScale;\n};\n/**\n * Returns a `MotionValue` each for `scaleX` and `scaleY` that update with the inverse\n * of their respective parent scales.\n *\n * This is useful for undoing the distortion of content when scaling a parent component.\n *\n * By default, `useInvertedScale` will automatically fetch `scaleX` and `scaleY` from the nearest parent.\n * By passing other `MotionValue`s in as `useInvertedScale({ scaleX, scaleY })`, it will invert the output\n * of those instead.\n *\n * @motion\n *\n * ```jsx\n * const MyComponent = () => {\n *   const { scaleX, scaleY } = useInvertedScale()\n *   return <motion.div style={{ scaleX, scaleY }} />\n * }\n * ```\n *\n * @library\n *\n * ```jsx\n * function MyComponent() {\n *   const { scaleX, scaleY } = useInvertedScale()\n *   return <Frame scaleX={scaleX} scaleY={scaleY} />\n * }\n * ```\n *\n * @public\n */\n\n\nfunction useInvertedScale(scale) {\n  var parentScaleX = useMotionValue(1);\n  var parentScaleY = useMotionValue(1);\n  var visualElement = useContext(MotionContext).visualElement;\n  invariant(!!(scale || visualElement), \"If no scale values are provided, useInvertedScale must be used within a child of another motion component.\");\n\n  if (scale) {\n    parentScaleX = scale.scaleX || parentScaleX;\n    parentScaleY = scale.scaleY || parentScaleY;\n  } else if (visualElement) {\n    parentScaleX = visualElement.getValue(\"scaleX\", 1);\n    parentScaleY = visualElement.getValue(\"scaleY\", 1);\n  }\n\n  var scaleX = useTransform(parentScaleX, invertScale);\n  var scaleY = useTransform(parentScaleY, invertScale);\n  return {\n    scaleX: scaleX,\n    scaleY: scaleY\n  };\n}\n\nfunction useOnChange(value, callback) {\n  useEffect(function () {\n    return isMotionValue(value) ? value.onChange(callback) : undefined;\n  }, [value]);\n}\n/**\n * Creates a `MotionValue` that, when `set`, will use a spring animation to animate to its new state.\n *\n * It can either work as a stand-alone `MotionValue` by initialising it with a value, or as a subscriber\n * to another `MotionValue`.\n *\n * @remarks\n *\n * ```jsx\n * const x = useSpring(0, { stiffness: 300 })\n * const y = useSpring(x, { damping: 10 })\n * ```\n *\n * @param inputValue - `MotionValue` or number. If provided a `MotionValue`, when the input `MotionValue` changes, the created `MotionValue` will spring towards that value.\n * @param springConfig - Configuration options for the spring.\n * @returns `MotionValue`\n *\n * @public\n */\n\n\nfunction useSpring(source, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  var activeSpringAnimation = useRef(null);\n  var value = useMotionValue(isMotionValue(source) ? source.get() : source);\n  useMemo(function () {\n    return value.attach(function (v, set) {\n      if (activeSpringAnimation.current) {\n        activeSpringAnimation.current.stop();\n      }\n\n      activeSpringAnimation.current = spring(__assign({\n        from: value.get(),\n        to: v,\n        velocity: value.getVelocity()\n      }, config)).start(set);\n      return value.get();\n    });\n  }, Object.values(config));\n  useOnChange(source, function (v) {\n    return value.set(parseFloat(v));\n  });\n  return value;\n}\n\nfunction createScrollMotionValues() {\n  return {\n    scrollX: motionValue(0),\n    scrollY: motionValue(0),\n    scrollXProgress: motionValue(0),\n    scrollYProgress: motionValue(0)\n  };\n}\n\nfunction setProgress(offset, maxOffset, value) {\n  value.set(!offset || !maxOffset ? 0 : offset / maxOffset);\n}\n\nfunction createScrollUpdater(values, getOffsets) {\n  var update = function update() {\n    var _a = getOffsets(),\n        xOffset = _a.xOffset,\n        yOffset = _a.yOffset,\n        xMaxOffset = _a.xMaxOffset,\n        yMaxOffset = _a.yMaxOffset; // Set absolute positions\n\n\n    values.scrollX.set(xOffset);\n    values.scrollY.set(yOffset); // Set 0-1 progress\n\n    setProgress(xOffset, xMaxOffset, values.scrollXProgress);\n    setProgress(yOffset, yMaxOffset, values.scrollYProgress);\n  };\n\n  update();\n  return update;\n}\n\nvar isBrowser$2 = typeof window !== \"undefined\";\nvar useIsomorphicLayoutEffect = isBrowser$2 ? useLayoutEffect : useEffect;\n\nvar getElementScrollOffsets = function getElementScrollOffsets(element) {\n  return function () {\n    return {\n      xOffset: element.scrollLeft,\n      yOffset: element.scrollTop,\n      xMaxOffset: element.scrollWidth - element.offsetWidth,\n      yMaxOffset: element.scrollHeight - element.offsetHeight\n    };\n  };\n};\n/**\n * Returns MotionValues that update when the provided element scrolls:\n *\n * - `scrollX` — Horizontal scroll distance in pixels.\n * - `scrollY` — Vertical scroll distance in pixels.\n * - `scrollXProgress` — Horizontal scroll progress between `0` and `1`.\n * - `scrollYProgress` — Vertical scroll progress between `0` and `1`.\n *\n * @library\n *\n * ```jsx\n * import * as React from \"react\"\n * import {\n *   Frame,\n *   useElementScroll,\n *   useTransform\n * } from \"framer\"\n *\n * export function MyComponent() {\n *   const ref = React.useRef()\n *   const { scrollYProgress } = useElementScroll(ref)\n *\n *   return (\n *     <Frame ref={ref}>\n *       <Frame scaleX={scrollYProgress} />\n *     </Frame>\n *   )\n * }\n * ```\n *\n * @motion\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const ref = useRef()\n *   const { scrollYProgress } = useElementScroll(ref)\n *\n *   return (\n *     <div ref={ref}>\n *       <motion.div style={{ scaleX: scrollYProgress }} />\n *     </div>\n *   )\n * }\n * ```\n *\n * @public\n */\n\n\nfunction useElementScroll(ref) {\n  var values = useConstant(createScrollMotionValues);\n  useIsomorphicLayoutEffect(function () {\n    var element = ref.current;\n    invariant(!!element, \"ref provided to useScroll must be passed into a HTML element.\");\n    if (!element) return;\n    var updateScrollValues = createScrollUpdater(values, getElementScrollOffsets(element));\n    var scrollListener = addDomEvent(element, \"scroll\", updateScrollValues, {\n      passive: true\n    });\n    var resizeListener = addDomEvent(element, \"resize\", updateScrollValues);\n    return function () {\n      scrollListener && scrollListener();\n      resizeListener && resizeListener();\n    };\n  }, []);\n  return values;\n}\n\nvar viewportScrollValues = createScrollMotionValues();\n\nfunction getViewportScrollOffsets() {\n  return {\n    xOffset: window.pageXOffset,\n    yOffset: window.pageYOffset,\n    xMaxOffset: document.body.clientWidth - window.innerWidth,\n    yMaxOffset: document.body.clientHeight - window.innerHeight\n  };\n}\n\nvar hasListeners = false;\n\nfunction addEventListeners() {\n  hasListeners = true;\n  if (typeof window === \"undefined\") return;\n  var updateScrollValues = createScrollUpdater(viewportScrollValues, getViewportScrollOffsets);\n  addDomEvent(window, \"scroll\", updateScrollValues, {\n    passive: true\n  });\n  addDomEvent(window, \"resize\", updateScrollValues);\n}\n/**\n * Returns MotionValues that update when the viewport scrolls:\n *\n * - `scrollX` — Horizontal scroll distance in pixels.\n * - `scrollY` — Vertical scroll distance in pixels.\n * - `scrollXProgress` — Horizontal scroll progress between `0` and `1`.\n * - `scrollYProgress` — Vertical scroll progress between `0` and `1`.\n *\n * @library\n *\n * ```jsx\n * import * as React from \"react\"\n * import {\n *   Frame,\n *   useViewportScroll,\n *   useTransform\n * } from \"framer\"\n *\n * export function MyComponent() {\n *   const { scrollYProgress } = useViewportScroll()\n *   return <Frame scaleX={scrollYProgress} />\n * }\n * ```\n *\n * @motion\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const { scrollYProgress } = useViewportScroll()\n *   return <motion.div style={{ scaleX: scrollYProgress }} />\n * }\n * ```\n *\n * @public\n */\n\n\nfunction useViewportScroll() {\n  useIsomorphicLayoutEffect(function () {\n    !hasListeners && addEventListeners();\n  }, []);\n  return viewportScrollValues;\n}\n/**\n * Creates `AnimationControls`, which can be used to manually start, stop\n * and sequence animations on one or more components.\n *\n * The returned `AnimationControls` should be passed to the `animate` property\n * of the components you want to animate.\n *\n * These components can then be animated with the `start` method.\n *\n * @library\n *\n * ```jsx\n * import * as React from 'react'\n * import { Frame, useAnimation } from 'framer'\n *\n * export function MyComponent(props) {\n *    const controls = useAnimation()\n *\n *    controls.start({\n *        x: 100,\n *        transition: { duration: 0.5 },\n *    })\n *\n *    return <Frame animate={controls} />\n * }\n * ```\n *\n * @motion\n *\n * ```jsx\n * import * as React from 'react'\n * import { motion, useAnimation } from 'framer-motion'\n *\n * export function MyComponent(props) {\n *    const controls = useAnimation()\n *\n *    controls.start({\n *        x: 100,\n *        transition: { duration: 0.5 },\n *    })\n *\n *    return <motion.div animate={controls} />\n * }\n * ```\n *\n * @returns Animation controller with `start` and `stop` methods\n *\n * @public\n */\n\n\nfunction useAnimation() {\n  var animationControls = useConstant(function () {\n    return new AnimationControls();\n  });\n  useEffect(function () {\n    animationControls.mount();\n    return function () {\n      return animationControls.unmount();\n    };\n  }, []);\n  return animationControls;\n}\n/**\n * Cycles through a series of visual properties. Can be used to toggle between or cycle through animations. It works similar to `useState` in React. It is provided an initial array of possible states, and returns an array of two arguments.\n *\n * @library\n *\n * ```jsx\n * import * as React from \"react\"\n * import { Frame, useCycle } from \"framer\"\n *\n * export function MyComponent() {\n *   const [x, cycleX] = useCycle(0, 50, 100)\n *\n *   return (\n *     <Frame\n *       animate={{ x: x }}\n *       onTap={() => cycleX()}\n *      />\n *    )\n * }\n * ```\n *\n * @motion\n *\n * An index value can be passed to the returned `cycle` function to cycle to a specific index.\n *\n * ```jsx\n * import * as React from \"react\"\n * import { motion, useCycle } from \"framer-motion\"\n *\n * export const MyComponent = () => {\n *   const [x, cycleX] = useCycle(0, 50, 100)\n *\n *   return (\n *     <motion.div\n *       animate={{ x: x }}\n *       onTap={() => cycleX()}\n *      />\n *    )\n * }\n * ```\n *\n * @param items - items to cycle through\n * @returns [currentState, cycleState]\n *\n * @public\n */\n\n\nfunction useCycle() {\n  var items = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    items[_i] = arguments[_i];\n  } // TODO: After Framer X beta, remove this warning\n\n\n  warning(items.length > 1, \"useCycle syntax has changed. `useCycle([0, 1, 2])` becomes `useCycle(0, 1, 2)`\");\n  var index = useRef(0);\n\n  var _a = useState(items[index.current]),\n      item = _a[0],\n      setItem = _a[1];\n\n  return [item, function (next) {\n    index.current = typeof next !== \"number\" ? wrap(0, items.length, index.current + 1) : next;\n    setItem(items[index.current]);\n  }];\n} // Does this device prefer reduced motion? Returns `null` server-side.\n\n\nvar prefersReducedMotion = motionValue(null);\n\nif (typeof window !== \"undefined\") {\n  if (window.matchMedia) {\n    var motionMediaQuery_1 = window.matchMedia(\"(prefers-reduced-motion)\");\n\n    var setReducedMotionPreferences = function setReducedMotionPreferences() {\n      return prefersReducedMotion.set(motionMediaQuery_1.matches);\n    };\n\n    motionMediaQuery_1.addListener(setReducedMotionPreferences);\n    setReducedMotionPreferences();\n  } else {\n    prefersReducedMotion.set(false);\n  }\n}\n\nfunction determineShouldReduceMotion(prefersReduced, isReducedMotion) {\n  return typeof isReducedMotion === \"boolean\" ? isReducedMotion : Boolean(prefersReduced);\n}\n/**\n * A hook that returns `true` if we should be using reduced motion based on the current device's Reduced Motion setting.\n *\n * This can be used to implement changes to your UI based on Reduced Motion. For instance, replacing motion-sickness inducing\n * `x`/`y` animations with `opacity`, disabling the autoplay of background videos, or turning off parallax motion.\n *\n * It will actively respond to changes and re-render your components with the latest setting.\n *\n * ```jsx\n * export function Sidebar({ isOpen }) {\n *   const shouldReduceMotion = useReducedMotion()\n *   const closedX = shouldReduceMotion ? 0 : \"-100%\"\n *\n *   return (\n *     <motion.div animate={{\n *       opacity: isOpen ? 1 : 0,\n *       x: isOpen ? 0 : closedX\n *     }} />\n *   )\n * }\n * ```\n *\n * @return boolean\n *\n * @public\n */\n\n\nfunction useReducedMotion() {\n  var isReducedMotion = useContext(MotionContext).isReducedMotion;\n\n  var _a = useState(determineShouldReduceMotion(prefersReducedMotion.get(), isReducedMotion)),\n      shouldReduceMotion = _a[0],\n      setShouldReduceMotion = _a[1];\n\n  useEffect(function () {\n    return prefersReducedMotion.onChange(function (v) {\n      setShouldReduceMotion(determineShouldReduceMotion(v, isReducedMotion));\n    });\n  }, [setShouldReduceMotion, isReducedMotion]);\n  return shouldReduceMotion;\n}\n/**\n * Define accessibility options for a tree. Can be used to force the tree into Reduced Motion mode,\n * or disable device detection.\n *\n * @internal\n */\n\n\nfunction ReducedMotion(_a) {\n  var children = _a.children,\n      enabled = _a.enabled;\n  var context = useContext(MotionContext);\n  context = useMemo(function () {\n    return __assign(__assign({}, context), {\n      isReducedMotion: enabled\n    });\n  }, [enabled]);\n  return createElement(MotionContext.Provider, {\n    value: context\n  }, children);\n}\n/**\n * Can manually trigger a drag gesture on one or more `drag`-enabled `motion` components.\n *\n * @library\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <Frame onTapStart={startDrag} />\n *     <Frame drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @motion\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <div onMouseDown={startDrag} />\n *     <motion.div drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @public\n */\n\n\nvar DragControls =\n/** @class */\nfunction () {\n  function DragControls() {\n    this.componentControls = new Set();\n  }\n  /**\n   * Subscribe a component's internal `VisualElementDragControls` to the user-facing API.\n   *\n   * @internal\n   */\n\n\n  DragControls.prototype.subscribe = function (controls) {\n    var _this = this;\n\n    this.componentControls.add(controls);\n    return function () {\n      return _this.componentControls[\"delete\"](controls);\n    };\n  };\n  /**\n   * Start a drag gesture on every `motion` component that has this set of drag controls\n   * passed into it via the `dragControls` prop.\n   *\n   * ```jsx\n   * dragControls.start(e, {\n   *   snapToCursor: true\n   * })\n   * ```\n   *\n   * @param event - A mouse/touch/pointer event.\n   * @param options - Options\n   *\n   * @public\n   */\n\n\n  DragControls.prototype.start = function (event, options) {\n    this.componentControls.forEach(function (controls) {\n      controls.start(event.nativeEvent || event, options);\n    });\n  };\n\n  return DragControls;\n}();\n\nvar createDragControls = function createDragControls() {\n  return new DragControls();\n};\n/**\n * Usually, dragging is initiated by pressing down on a `motion` component with a `drag` prop\n * and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we\n * might want to initiate that dragging from a different component than the draggable one.\n *\n * By creating a `dragControls` using the `useDragControls` hook, we can pass this into\n * the draggable component's `dragControls` prop. It exposes a `start` method\n * that can start dragging from pointer events on other components.\n *\n * @library\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <Frame onTapStart={startDrag} />\n *     <Frame drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @motion\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <div onMouseDown={startDrag} />\n *     <motion.div drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @public\n */\n\n\nfunction useDragControls() {\n  return useConstant(createDragControls);\n}\n/**\n * Uses the ref that is passed in, or creates a new one\n * @param external - External ref\n * @internal\n */\n\n\nfunction useExternalRef(externalRef) {\n  // We're conditionally calling `useRef` here which is sort of naughty as hooks\n  // shouldn't be called conditionally. However, Framer Motion will break if this\n  // condition changes anyway. It might be possible to use an invariant here to\n  // make it explicit, but I expect changing `ref` is not normal behaviour.\n  var ref = !externalRef || typeof externalRef === \"function\" ? useRef(null) : externalRef; // Handle `ref` functions. Again, calling the hook conditionally is kind of naughty\n  // but `ref` types changing between renders would break Motion anyway. If we receive\n  // bug reports about this, we should track the provided ref and throw an invariant\n  // rather than move the conditional to inside the useEffect as this will be fired\n  // for every Frame component within Framer.\n\n  if (externalRef && typeof externalRef === \"function\") {\n    useEffect(function () {\n      externalRef(ref.current);\n      return function () {\n        return externalRef(null);\n      };\n    }, []);\n  }\n\n  return ref;\n}\n/**\n * This is just a very basic VisualElement, more of a hack to keep supporting useAnimatedState with\n * the latest APIs.\n */\n\n\nvar StateVisualElement =\n/** @class */\nfunction (_super) {\n  __extends(StateVisualElement, _super);\n\n  function StateVisualElement() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.initialState = {};\n    return _this;\n  }\n\n  StateVisualElement.prototype.build = function () {};\n\n  StateVisualElement.prototype.clean = function () {};\n\n  StateVisualElement.prototype.getBoundingBox = function () {\n    return {\n      x: {\n        min: 0,\n        max: 0\n      },\n      y: {\n        min: 0,\n        max: 0\n      }\n    };\n  };\n\n  StateVisualElement.prototype.readNativeValue = function (key) {\n    return this.initialState[key] || 0;\n  };\n\n  StateVisualElement.prototype.render = function () {\n    this.build();\n  };\n\n  return StateVisualElement;\n}(VisualElement);\n/**\n * This is not an officially supported API and may be removed\n * on any version.\n * @internal\n */\n\n\nfunction useAnimatedState(initialState) {\n  var _a = useState(initialState),\n      animationState = _a[0],\n      setAnimationState = _a[1];\n\n  var visualElement = useConstant(function () {\n    return new StateVisualElement();\n  });\n  visualElement.updateConfig({\n    onUpdate: function onUpdate(v) {\n      return setAnimationState(__assign({}, v));\n    }\n  });\n  visualElement.initialState = initialState;\n  var controls = useVisualElementAnimation(visualElement, {}, {});\n  useEffect(function () {\n    visualElement.mount({});\n    return function () {\n      return visualElement.unmount();\n    };\n  }, []);\n  var startAnimation = useConstant(function () {\n    return function (animationDefinition) {\n      return controls.start(animationDefinition);\n    };\n  });\n  return [animationState, startAnimation];\n}\n\nexport { AnimatePresence, AnimateSharedLayout, AnimationControls, DragControls, MotionContext, MotionPluginContext, MotionPlugins, MotionValue, PresenceContext, ReducedMotion, VisualElementAnimationControls, addScaleCorrection, animationControls, createMotionComponent, isValidMotionProp, motion, motionValue, resolveMotionValue, transform, useAnimatedState, useAnimation, useCycle, useDomEvent, useDragControls, useElementScroll, useExternalRef, useGestures, useInvertedScale, useIsPresent, useMotionValue, usePanGesture, usePresence, useReducedMotion, useSpring, useTapGesture, useTransform, useViewportScroll };"],"sourceRoot":""}